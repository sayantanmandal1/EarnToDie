/**\n * Service Worker for Zombie Car Game PWA\n * Handles caching, offline functionality, and background sync\n */\n\nconst CACHE_NAME = 'zombie-car-game-v1.0.0';\nconst STATIC_CACHE = 'static-cache-v1';\nconst DYNAMIC_CACHE = 'dynamic-cache-v1';\n\n// Files to cache for offline functionality\nconst STATIC_FILES = [\n    '/',\n    '/index.html',\n    '/manifest.json',\n    '/static/css/main.css',\n    '/static/js/main.js',\n    '/assets/icon.svg',\n    '/assets/icon-192.png',\n    '/assets/icon-512.png'\n];\n\n// Install event - cache static files\nself.addEventListener('install', (event) => {\n    console.log('Service Worker installing...');\n    \n    event.waitUntil(\n        caches.open(STATIC_CACHE)\n            .then((cache) => {\n                console.log('Caching static files');\n                return cache.addAll(STATIC_FILES);\n            })\n            .then(() => {\n                return self.skipWaiting();\n            })\n            .catch((error) => {\n                console.error('Failed to cache static files:', error);\n            })\n    );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n    console.log('Service Worker activating...');\n    \n    event.waitUntil(\n        caches.keys()\n            .then((cacheNames) => {\n                return Promise.all(\n                    cacheNames.map((cacheName) => {\n                        if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\n                            console.log('Deleting old cache:', cacheName);\n                            return caches.delete(cacheName);\n                        }\n                    })\n                );\n            })\n            .then(() => {\n                return self.clients.claim();\n            })\n    );\n});\n\n// Fetch event - serve cached files or fetch from network\nself.addEventListener('fetch', (event) => {\n    const { request } = event;\n    const url = new URL(request.url);\n    \n    // Skip non-GET requests\n    if (request.method !== 'GET') {\n        return;\n    }\n    \n    // Handle different types of requests\n    if (url.origin === location.origin) {\n        // Same origin requests\n        event.respondWith(handleSameOriginRequest(request));\n    } else {\n        // Cross-origin requests (APIs, CDNs, etc.)\n        event.respondWith(handleCrossOriginRequest(request));\n    }\n});\n\n/**\n * Handle same-origin requests with cache-first strategy for static files\n * and network-first strategy for dynamic content\n */\nasync function handleSameOriginRequest(request) {\n    const url = new URL(request.url);\n    \n    // Static files - cache first\n    if (isStaticFile(url.pathname)) {\n        return handleStaticFile(request);\n    }\n    \n    // API requests - network first\n    if (url.pathname.startsWith('/api/')) {\n        return handleApiRequest(request);\n    }\n    \n    // Game assets - cache first with fallback\n    if (isGameAsset(url.pathname)) {\n        return handleGameAsset(request);\n    }\n    \n    // Default - network first\n    return handleNetworkFirst(request);\n}\n\n/**\n * Handle cross-origin requests\n */\nasync function handleCrossOriginRequest(request) {\n    try {\n        // Try network first for cross-origin\n        const response = await fetch(request);\n        \n        // Cache successful responses\n        if (response.ok) {\n            const cache = await caches.open(DYNAMIC_CACHE);\n            cache.put(request, response.clone());\n        }\n        \n        return response;\n    } catch (error) {\n        // Fallback to cache\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return offline fallback\n        return new Response('Offline', {\n            status: 503,\n            statusText: 'Service Unavailable'\n        });\n    }\n}\n\n/**\n * Handle static files with cache-first strategy\n */\nasync function handleStaticFile(request) {\n    const cachedResponse = await caches.match(request);\n    \n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    try {\n        const response = await fetch(request);\n        \n        if (response.ok) {\n            const cache = await caches.open(STATIC_CACHE);\n            cache.put(request, response.clone());\n        }\n        \n        return response;\n    } catch (error) {\n        // Return offline fallback for HTML files\n        if (request.destination === 'document') {\n            const offlineResponse = await caches.match('/index.html');\n            return offlineResponse || new Response('Offline', {\n                status: 503,\n                statusText: 'Service Unavailable'\n            });\n        }\n        \n        throw error;\n    }\n}\n\n/**\n * Handle API requests with network-first strategy\n */\nasync function handleApiRequest(request) {\n    try {\n        const response = await fetch(request);\n        \n        // Cache successful GET requests\n        if (response.ok && request.method === 'GET') {\n            const cache = await caches.open(DYNAMIC_CACHE);\n            cache.put(request, response.clone());\n        }\n        \n        return response;\n    } catch (error) {\n        // Fallback to cache for GET requests\n        if (request.method === 'GET') {\n            const cachedResponse = await caches.match(request);\n            if (cachedResponse) {\n                return cachedResponse;\n            }\n        }\n        \n        // Return error response\n        return new Response(JSON.stringify({\n            error: 'Network unavailable',\n            offline: true\n        }), {\n            status: 503,\n            statusText: 'Service Unavailable',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n    }\n}\n\n/**\n * Handle game assets with cache-first strategy\n */\nasync function handleGameAsset(request) {\n    const cachedResponse = await caches.match(request);\n    \n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    try {\n        const response = await fetch(request);\n        \n        if (response.ok) {\n            const cache = await caches.open(DYNAMIC_CACHE);\n            cache.put(request, response.clone());\n        }\n        \n        return response;\n    } catch (error) {\n        // Return placeholder for missing assets\n        return new Response('Asset unavailable offline', {\n            status: 503,\n            statusText: 'Service Unavailable'\n        });\n    }\n}\n\n/**\n * Handle requests with network-first strategy\n */\nasync function handleNetworkFirst(request) {\n    try {\n        const response = await fetch(request);\n        \n        if (response.ok) {\n            const cache = await caches.open(DYNAMIC_CACHE);\n            cache.put(request, response.clone());\n        }\n        \n        return response;\n    } catch (error) {\n        const cachedResponse = await caches.match(request);\n        return cachedResponse || new Response('Offline', {\n            status: 503,\n            statusText: 'Service Unavailable'\n        });\n    }\n}\n\n/**\n * Check if a path is a static file\n */\nfunction isStaticFile(pathname) {\n    return pathname.startsWith('/static/') || \n           pathname.endsWith('.html') ||\n           pathname.endsWith('.css') ||\n           pathname.endsWith('.js') ||\n           pathname === '/' ||\n           pathname === '/manifest.json';\n}\n\n/**\n * Check if a path is a game asset\n */\nfunction isGameAsset(pathname) {\n    return pathname.startsWith('/assets/') ||\n           pathname.startsWith('/audio/') ||\n           pathname.startsWith('/models/') ||\n           pathname.startsWith('/textures/') ||\n           pathname.endsWith('.png') ||\n           pathname.endsWith('.jpg') ||\n           pathname.endsWith('.jpeg') ||\n           pathname.endsWith('.webp') ||\n           pathname.endsWith('.svg') ||\n           pathname.endsWith('.mp3') ||\n           pathname.endsWith('.wav') ||\n           pathname.endsWith('.ogg');\n}\n\n// Background sync for offline actions\nself.addEventListener('sync', (event) => {\n    console.log('Background sync triggered:', event.tag);\n    \n    if (event.tag === 'save-game-data') {\n        event.waitUntil(syncGameData());\n    } else if (event.tag === 'upload-scores') {\n        event.waitUntil(syncScores());\n    }\n});\n\n/**\n * Sync game data when back online\n */\nasync function syncGameData() {\n    try {\n        // Get pending save data from IndexedDB\n        const pendingSaves = await getPendingSaves();\n        \n        for (const save of pendingSaves) {\n            try {\n                const response = await fetch('/api/save', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(save.data)\n                });\n                \n                if (response.ok) {\n                    await removePendingSave(save.id);\n                    console.log('Synced save data:', save.id);\n                }\n            } catch (error) {\n                console.error('Failed to sync save data:', error);\n            }\n        }\n    } catch (error) {\n        console.error('Background sync failed:', error);\n    }\n}\n\n/**\n * Sync scores when back online\n */\nasync function syncScores() {\n    try {\n        // Get pending scores from IndexedDB\n        const pendingScores = await getPendingScores();\n        \n        for (const score of pendingScores) {\n            try {\n                const response = await fetch('/api/scores', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(score.data)\n                });\n                \n                if (response.ok) {\n                    await removePendingScore(score.id);\n                    console.log('Synced score:', score.id);\n                }\n            } catch (error) {\n                console.error('Failed to sync score:', error);\n            }\n        }\n    } catch (error) {\n        console.error('Score sync failed:', error);\n    }\n}\n\n// Placeholder functions for IndexedDB operations\n// These would be implemented with actual IndexedDB code\nasync function getPendingSaves() {\n    // Implementation would retrieve pending saves from IndexedDB\n    return [];\n}\n\nasync function removePendingSave(id) {\n    // Implementation would remove save from IndexedDB\n}\n\nasync function getPendingScores() {\n    // Implementation would retrieve pending scores from IndexedDB\n    return [];\n}\n\nasync function removePendingScore(id) {\n    // Implementation would remove score from IndexedDB\n}\n\n// Push notification handling\nself.addEventListener('push', (event) => {\n    console.log('Push notification received');\n    \n    const options = {\n        body: 'New content available in Zombie Car Game!',\n        icon: '/assets/icon-192.png',\n        badge: '/assets/icon-192.png',\n        vibrate: [200, 100, 200],\n        data: {\n            url: '/'\n        },\n        actions: [\n            {\n                action: 'open',\n                title: 'Open Game'\n            },\n            {\n                action: 'close',\n                title: 'Close'\n            }\n        ]\n    };\n    \n    if (event.data) {\n        const data = event.data.json();\n        options.body = data.body || options.body;\n        options.data.url = data.url || options.data.url;\n    }\n    \n    event.waitUntil(\n        self.registration.showNotification('Zombie Car Game', options)\n    );\n});\n\n// Notification click handling\nself.addEventListener('notificationclick', (event) => {\n    console.log('Notification clicked:', event.action);\n    \n    event.notification.close();\n    \n    if (event.action === 'open' || !event.action) {\n        event.waitUntil(\n            clients.openWindow(event.notification.data.url || '/')\n        );\n    }\n});"