/**\n * Asset Repair System\n * Handles automatic asset repair and re-download functionality\n */\nclass AssetRepairSystem {\n    constructor(verificationSystem, config = {}) {\n        this.verificationSystem = verificationSystem;\n        \n        this.config = {\n            maxConcurrentDownloads: 3,\n            maxRetryAttempts: 3,\n            retryDelay: 2000,\n            downloadTimeout: 30000,\n            enableProgressReporting: true,\n            enableCaching: true,\n            enableBackup: true,\n            backupRetentionDays: 7,\n            debugMode: process.env.NODE_ENV === 'development',\n            ...config\n        };\n        \n        // Repair state\n        this.repairQueue = [];\n        this.activeDownloads = new Map();\n        this.repairHistory = [];\n        this.backupAssets = new Map();\n        \n        // Progress tracking\n        this.repairProgress = {\n            total: 0,\n            completed: 0,\n            failed: 0,\n            inProgress: 0,\n            status: 'idle' // 'idle', 'repairing', 'complete', 'error'\n        };\n        \n        // Performance metrics\n        this.metrics = {\n            totalRepairs: 0,\n            totalDownloads: 0,\n            totalBytes: 0,\n            averageDownloadSpeed: 0,\n            successRate: 0,\n            lastRepairTime: null\n        };\n        \n        // Event listeners\n        this.eventListeners = new Map();\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialize repair system\n     */\n    initialize() {\n        console.log('Initializing Asset Repair System...');\n        \n        // Setup event listeners from verification system\n        if (this.verificationSystem) {\n            this.verificationSystem.on('verificationCompleted', (results) => {\n                if (results.corrupted > 0 || results.missing > 0) {\n                    this.scheduleRepair();\n                }\n            });\n        }\n        \n        // Setup periodic cleanup\n        this.setupPeriodicCleanup();\n        \n        console.log('Asset Repair System initialized');\n    }\n    \n    /**\n     * Schedule repair for corrupted/missing assets\n     */\n    async scheduleRepair() {\n        if (!this.verificationSystem) {\n            throw new Error('No verification system available');\n        }\n        \n        const corruptedAssets = Array.from(this.verificationSystem.corruptedAssets);\n        const missingAssets = Array.from(this.verificationSystem.missingAssets);\n        const assetsToRepair = [...corruptedAssets, ...missingAssets];\n        \n        if (assetsToRepair.length === 0) {\n            console.log('No assets need repair');\n            return;\n        }\n        \n        console.log(`Scheduling repair for ${assetsToRepair.length} assets`);\n        \n        // Add to repair queue\n        for (const assetPath of assetsToRepair) {\n            if (!this.repairQueue.find(item => item.path === assetPath)) {\n                const assetInfo = this.verificationSystem.manifest.assets[assetPath];\n                if (assetInfo) {\n                    this.repairQueue.push({\n                        path: assetPath,\n                        info: assetInfo,\n                        attempts: 0,\n                        priority: assetInfo.critical ? 1 : 2,\n                        addedAt: Date.now()\n                    });\n                }\n            }\n        }\n        \n        // Sort by priority (critical assets first)\n        this.repairQueue.sort((a, b) => a.priority - b.priority);\n        \n        // Start repair process\n        await this.processRepairQueue();\n    }\n    \n    /**\n     * Process repair queue\n     */\n    async processRepairQueue() {\n        if (this.repairQueue.length === 0) {\n            console.log('Repair queue is empty');\n            return;\n        }\n        \n        console.log(`Processing repair queue: ${this.repairQueue.length} assets`);\n        \n        // Update progress\n        this.repairProgress = {\n            total: this.repairQueue.length,\n            completed: 0,\n            failed: 0,\n            inProgress: 0,\n            status: 'repairing'\n        };\n        \n        this.emit('repairStarted', { total: this.repairProgress.total });\n        \n        try {\n            // Process assets with concurrency limit\n            const promises = [];\n            \n            while (this.repairQueue.length > 0 || promises.length > 0) {\n                // Start new downloads up to concurrency limit\n                while (promises.length < this.config.maxConcurrentDownloads && this.repairQueue.length > 0) {\n                    const asset = this.repairQueue.shift();\n                    const promise = this.repairAsset(asset)\n                        .then(result => ({ asset, result }))\n                        .catch(error => ({ asset, error }));\n                    \n                    promises.push(promise);\n                    this.repairProgress.inProgress++;\n                }\n                \n                // Wait for at least one download to complete\n                if (promises.length > 0) {\n                    const completed = await Promise.race(promises);\n                    const index = promises.findIndex(p => p === Promise.resolve(completed));\n                    promises.splice(index, 1);\n                    \n                    this.repairProgress.inProgress--;\n                    \n                    if (completed.error) {\n                        console.error(`Failed to repair asset ${completed.asset.path}:`, completed.error);\n                        this.repairProgress.failed++;\n                        \n                        // Retry if attempts remaining\n                        if (completed.asset.attempts < this.config.maxRetryAttempts) {\n                            completed.asset.attempts++;\n                            this.repairQueue.push(completed.asset);\n                        }\n                    } else {\n                        console.log(`Successfully repaired asset: ${completed.asset.path}`);\n                        this.repairProgress.completed++;\n                        this.metrics.totalRepairs++;\n                    }\n                    \n                    // Report progress\n                    this.emit('repairProgress', { ...this.repairProgress });\n                }\n            }\n            \n            // Update final status\n            this.repairProgress.status = 'complete';\n            this.metrics.lastRepairTime = Date.now();\n            this.metrics.successRate = this.repairProgress.completed / this.repairProgress.total;\n            \n            const results = {\n                total: this.repairProgress.total,\n                completed: this.repairProgress.completed,\n                failed: this.repairProgress.failed\n            };\n            \n            console.log('Repair process completed:', results);\n            this.emit('repairCompleted', results);\n            \n            return results;\n            \n        } catch (error) {\n            this.repairProgress.status = 'error';\n            console.error('Repair process failed:', error);\n            this.emit('repairError', { error });\n            throw error;\n        }\n    }\n    \n    /**\n     * Repair single asset\n     */\n    async repairAsset(assetItem) {\n        const { path, info } = assetItem;\n        const startTime = performance.now();\n        \n        try {\n            console.log(`Repairing asset: ${path}`);\n            \n            // Backup current asset if it exists\n            if (this.config.enableBackup) {\n                await this.backupAsset(path);\n            }\n            \n            // Download asset\n            const downloadResult = await this.downloadAsset(path, info);\n            \n            // Verify downloaded asset\n            const verificationResult = await this.verifyDownloadedAsset(path, downloadResult.data, info);\n            \n            if (!verificationResult.valid) {\n                throw new Error(`Downloaded asset verification failed: ${verificationResult.error}`);\n            }\n            \n            // Cache repaired asset\n            if (this.config.enableCaching) {\n                await this.cacheRepairedAsset(path, downloadResult.data);\n            }\n            \n            // Update metrics\n            const endTime = performance.now();\n            const downloadTime = endTime - startTime;\n            const downloadSpeed = downloadResult.data.byteLength / (downloadTime / 1000); // bytes per second\n            \n            this.metrics.totalDownloads++;\n            this.metrics.totalBytes += downloadResult.data.byteLength;\n            this.metrics.averageDownloadSpeed = \n                (this.metrics.averageDownloadSpeed * (this.metrics.totalDownloads - 1) + downloadSpeed) / \n                this.metrics.totalDownloads;\n            \n            // Add to repair history\n            this.repairHistory.push({\n                path,\n                timestamp: Date.now(),\n                size: downloadResult.data.byteLength,\n                downloadTime,\n                downloadSpeed,\n                attempts: assetItem.attempts + 1,\n                success: true\n            });\n            \n            // Remove from verification system's corrupted/missing sets\n            if (this.verificationSystem) {\n                this.verificationSystem.corruptedAssets.delete(path);\n                this.verificationSystem.missingAssets.delete(path);\n                this.verificationSystem.repairedAssets.add(path);\n            }\n            \n            return {\n                success: true,\n                size: downloadResult.data.byteLength,\n                downloadTime,\n                downloadSpeed\n            };\n            \n        } catch (error) {\n            // Add to repair history\n            this.repairHistory.push({\n                path,\n                timestamp: Date.now(),\n                attempts: assetItem.attempts + 1,\n                success: false,\n                error: error.message\n            });\n            \n            throw error;\n        }\n    }\n    \n    /**\n     * Download asset with progress tracking\n     */\n    async downloadAsset(path, info) {\n        const downloadUrl = info.downloadUrl || path;\n        \n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            const startTime = performance.now();\n            \n            // Setup timeout\n            const timeout = setTimeout(() => {\n                xhr.abort();\n                reject(new Error(`Download timeout for ${path}`));\n            }, this.config.downloadTimeout);\n            \n            xhr.open('GET', downloadUrl, true);\n            xhr.responseType = 'arraybuffer';\n            \n            // Progress tracking\n            xhr.onprogress = (event) => {\n                if (event.lengthComputable) {\n                    const progress = {\n                        path,\n                        loaded: event.loaded,\n                        total: event.total,\n                        percentage: (event.loaded / event.total) * 100\n                    };\n                    \n                    this.emit('downloadProgress', progress);\n                }\n            };\n            \n            xhr.onload = () => {\n                clearTimeout(timeout);\n                \n                if (xhr.status >= 200 && xhr.status < 300) {\n                    const endTime = performance.now();\n                    resolve({\n                        data: xhr.response,\n                        downloadTime: endTime - startTime,\n                        size: xhr.response.byteLength\n                    });\n                } else {\n                    reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));\n                }\n            };\n            \n            xhr.onerror = () => {\n                clearTimeout(timeout);\n                reject(new Error(`Network error downloading ${path}`));\n            };\n            \n            xhr.onabort = () => {\n                clearTimeout(timeout);\n                reject(new Error(`Download aborted for ${path}`));\n            };\n            \n            // Add to active downloads\n            this.activeDownloads.set(path, xhr);\n            \n            xhr.send();\n        }).finally(() => {\n            // Remove from active downloads\n            this.activeDownloads.delete(path);\n        });\n    }\n    \n    /**\n     * Verify downloaded asset\n     */\n    async verifyDownloadedAsset(path, data, expectedInfo) {\n        try {\n            // Check size\n            if (data.byteLength !== expectedInfo.size) {\n                return {\n                    valid: false,\n                    error: `Size mismatch: expected ${expectedInfo.size}, got ${data.byteLength}`\n                };\n            }\n            \n            // Calculate checksum\n            const checksum = await this.calculateChecksum(data);\n            \n            // Check checksum\n            if (checksum !== expectedInfo.checksum) {\n                return {\n                    valid: false,\n                    error: `Checksum mismatch: expected ${expectedInfo.checksum}, got ${checksum}`\n                };\n            }\n            \n            return { valid: true };\n            \n        } catch (error) {\n            return {\n                valid: false,\n                error: `Verification error: ${error.message}`\n            };\n        }\n    }\n    \n    /**\n     * Calculate checksum\n     */\n    async calculateChecksum(data) {\n        if (window.crypto && window.crypto.subtle) {\n            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        } else {\n            // Fallback to simple hash\n            const bytes = new Uint8Array(data);\n            let hash = 0;\n            \n            for (let i = 0; i < bytes.length; i++) {\n                hash = ((hash << 5) - hash + bytes[i]) & 0xffffffff;\n            }\n            \n            return hash.toString(16);\n        }\n    }\n    \n    /**\n     * Backup asset before repair\n     */\n    async backupAsset(path) {\n        try {\n            // Try to fetch current asset\n            const response = await fetch(path);\n            if (response.ok) {\n                const data = await response.arrayBuffer();\n                \n                // Store backup\n                this.backupAssets.set(path, {\n                    data,\n                    timestamp: Date.now(),\n                    size: data.byteLength\n                });\n                \n                console.log(`Backed up asset: ${path}`);\n            }\n        } catch (error) {\n            console.warn(`Failed to backup asset ${path}:`, error);\n        }\n    }\n    \n    /**\n     * Cache repaired asset\n     */\n    async cacheRepairedAsset(path, data) {\n        try {\n            // Store in browser cache\n            if ('caches' in window) {\n                const cache = await caches.open('repaired-assets');\n                const response = new Response(data);\n                await cache.put(path, response);\n            }\n            \n            console.log(`Cached repaired asset: ${path}`);\n            \n        } catch (error) {\n            console.warn(`Failed to cache repaired asset ${path}:`, error);\n        }\n    }\n    \n    /**\n     * Restore asset from backup\n     */\n    async restoreAssetFromBackup(path) {\n        const backup = this.backupAssets.get(path);\n        if (!backup) {\n            throw new Error(`No backup available for asset: ${path}`);\n        }\n        \n        try {\n            // Cache restored asset\n            if (this.config.enableCaching) {\n                await this.cacheRepairedAsset(path, backup.data);\n            }\n            \n            console.log(`Restored asset from backup: ${path}`);\n            return true;\n            \n        } catch (error) {\n            console.error(`Failed to restore asset from backup ${path}:`, error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Cancel active downloads\n     */\n    cancelActiveDownloads() {\n        console.log(`Cancelling ${this.activeDownloads.size} active downloads`);\n        \n        for (const [path, xhr] of this.activeDownloads) {\n            xhr.abort();\n        }\n        \n        this.activeDownloads.clear();\n        this.repairProgress.status = 'cancelled';\n        \n        this.emit('repairCancelled', {});\n    }\n    \n    /**\n     * Get repair status\n     */\n    getRepairStatus() {\n        return {\n            progress: { ...this.repairProgress },\n            queueLength: this.repairQueue.length,\n            activeDownloads: this.activeDownloads.size,\n            metrics: { ...this.metrics }\n        };\n    }\n    \n    /**\n     * Get repair history\n     */\n    getRepairHistory(limit = 100) {\n        return this.repairHistory\n            .slice(-limit)\n            .sort((a, b) => b.timestamp - a.timestamp);\n    }\n    \n    /**\n     * Setup periodic cleanup\n     */\n    setupPeriodicCleanup() {\n        // Clean up old backups every hour\n        setInterval(() => {\n            this.cleanupOldBackups();\n        }, 3600000); // 1 hour\n        \n        // Clean up repair history every day\n        setInterval(() => {\n            this.cleanupRepairHistory();\n        }, 86400000); // 24 hours\n    }\n    \n    /**\n     * Cleanup old backups\n     */\n    cleanupOldBackups() {\n        const cutoffTime = Date.now() - (this.config.backupRetentionDays * 24 * 60 * 60 * 1000);\n        let cleaned = 0;\n        \n        for (const [path, backup] of this.backupAssets) {\n            if (backup.timestamp < cutoffTime) {\n                this.backupAssets.delete(path);\n                cleaned++;\n            }\n        }\n        \n        if (cleaned > 0) {\n            console.log(`Cleaned up ${cleaned} old asset backups`);\n        }\n    }\n    \n    /**\n     * Cleanup repair history\n     */\n    cleanupRepairHistory() {\n        const maxHistorySize = 1000;\n        \n        if (this.repairHistory.length > maxHistorySize) {\n            const removed = this.repairHistory.length - maxHistorySize;\n            this.repairHistory = this.repairHistory.slice(-maxHistorySize);\n            console.log(`Cleaned up ${removed} old repair history entries`);\n        }\n    }\n    \n    /**\n     * Event system\n     */\n    on(event, callback) {\n        if (!this.eventListeners.has(event)) {\n            this.eventListeners.set(event, []);\n        }\n        this.eventListeners.get(event).push(callback);\n    }\n    \n    off(event, callback) {\n        if (this.eventListeners.has(event)) {\n            const listeners = this.eventListeners.get(event);\n            const index = listeners.indexOf(callback);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    \n    emit(event, data) {\n        if (this.eventListeners.has(event)) {\n            this.eventListeners.get(event).forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`Error in event listener for ${event}:`, error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Update configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        console.log('Asset repair configuration updated:', this.config);\n    }\n    \n    /**\n     * Clear repair queue\n     */\n    clearRepairQueue() {\n        this.repairQueue = [];\n        console.log('Repair queue cleared');\n    }\n    \n    /**\n     * Get statistics\n     */\n    getStatistics() {\n        return {\n            metrics: { ...this.metrics },\n            progress: { ...this.repairProgress },\n            queueLength: this.repairQueue.length,\n            activeDownloads: this.activeDownloads.size,\n            backupCount: this.backupAssets.size,\n            historyCount: this.repairHistory.length\n        };\n    }\n    \n    /**\n     * Cleanup and destroy\n     */\n    destroy() {\n        // Cancel active downloads\n        this.cancelActiveDownloads();\n        \n        // Clear data\n        this.repairQueue = [];\n        this.repairHistory = [];\n        this.backupAssets.clear();\n        \n        // Clear event listeners\n        this.eventListeners.clear();\n        \n        console.log('Asset Repair System destroyed');\n    }\n}\n\nexport default AssetRepairSystem;"