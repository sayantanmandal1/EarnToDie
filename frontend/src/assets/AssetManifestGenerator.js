/**\n * Asset Manifest Generator\n * Generates asset manifests with checksums for verification\n */\nclass AssetManifestGenerator {\n    constructor(config = {}) {\n        this.config = {\n            baseUrl: '',\n            outputPath: '/assets/manifest.json',\n            checksumAlgorithm: 'SHA-256',\n            includePatterns: ['**/*.js', '**/*.css', '**/*.png', '**/*.jpg', '**/*.jpeg', '**/*.webp', '**/*.svg', '**/*.mp3', '**/*.wav', '**/*.ogg', '**/*.json'],\n            excludePatterns: ['**/node_modules/**', '**/.*', '**/*.map'],\n            criticalAssets: ['main.js', 'main.css', 'index.html'],\n            enableCompression: true,\n            enableCDN: false,\n            cdnBaseUrl: '',\n            ...config\n        };\n        \n        this.manifest = {\n            version: '1.0.0',\n            generated: null,\n            assets: {},\n            metadata: {\n                totalAssets: 0,\n                totalSize: 0,\n                compressionEnabled: this.config.enableCompression,\n                cdnEnabled: this.config.enableCDN\n            }\n        };\n        \n        this.stats = {\n            processed: 0,\n            skipped: 0,\n            errors: 0,\n            totalSize: 0\n        };\n    }\n    \n    /**\n     * Generate manifest from file system (Node.js environment)\n     */\n    async generateFromFileSystem(rootPath) {\n        if (typeof require === 'undefined') {\n            throw new Error('generateFromFileSystem requires Node.js environment');\n        }\n        \n        const fs = require('fs').promises;\n        const path = require('path');\n        const crypto = require('crypto');\n        const glob = require('glob');\n        \n        console.log('Generating asset manifest from file system...');\n        \n        try {\n            // Find all matching files\n            const files = await this.findFiles(rootPath);\n            console.log(`Found ${files.length} files to process`);\n            \n            // Process each file\n            for (const filePath of files) {\n                try {\n                    const relativePath = path.relative(rootPath, filePath);\n                    const urlPath = '/' + relativePath.replace(/\\\\/g, '/');\n                    \n                    // Read file\n                    const fileBuffer = await fs.readFile(filePath);\n                    \n                    // Calculate checksum\n                    const checksum = crypto.createHash('sha256').update(fileBuffer).digest('hex');\n                    \n                    // Get file stats\n                    const stats = await fs.stat(filePath);\n                    \n                    // Determine asset type\n                    const assetType = this.getAssetType(filePath);\n                    \n                    // Check if critical\n                    const isCritical = this.config.criticalAssets.some(pattern => \n                        relativePath.includes(pattern) || urlPath.includes(pattern)\n                    );\n                    \n                    // Add to manifest\n                    this.manifest.assets[urlPath] = {\n                        checksum,\n                        size: stats.size,\n                        type: assetType,\n                        critical: isCritical,\n                        lastModified: stats.mtime.toISOString(),\n                        downloadUrl: this.config.enableCDN ? \n                            `${this.config.cdnBaseUrl}${urlPath}` : \n                            `${this.config.baseUrl}${urlPath}`\n                    };\n                    \n                    this.stats.processed++;\n                    this.stats.totalSize += stats.size;\n                    \n                } catch (error) {\n                    console.error(`Failed to process file ${filePath}:`, error);\n                    this.stats.errors++;\n                }\n            }\n            \n            // Update metadata\n            this.manifest.generated = new Date().toISOString();\n            this.manifest.metadata.totalAssets = this.stats.processed;\n            this.manifest.metadata.totalSize = this.stats.totalSize;\n            \n            console.log('Manifest generation completed:', this.stats);\n            return this.manifest;\n            \n        } catch (error) {\n            console.error('Failed to generate manifest:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Generate manifest from asset list (browser environment)\n     */\n    async generateFromAssetList(assetList) {\n        console.log('Generating asset manifest from asset list...');\n        \n        try {\n            for (const asset of assetList) {\n                try {\n                    let assetData;\n                    \n                    if (asset.data) {\n                        // Asset data provided directly\n                        assetData = asset.data;\n                    } else if (asset.url) {\n                        // Fetch asset data\n                        const response = await fetch(asset.url);\n                        if (!response.ok) {\n                            throw new Error(`Failed to fetch ${asset.url}: ${response.status}`);\n                        }\n                        assetData = await response.arrayBuffer();\n                    } else {\n                        throw new Error('Asset must have either data or url property');\n                    }\n                    \n                    // Calculate checksum\n                    const checksum = await this.calculateChecksum(assetData);\n                    \n                    // Determine asset type\n                    const assetType = asset.type || this.getAssetType(asset.path);\n                    \n                    // Check if critical\n                    const isCritical = asset.critical || this.config.criticalAssets.some(pattern => \n                        asset.path.includes(pattern)\n                    );\n                    \n                    // Add to manifest\n                    this.manifest.assets[asset.path] = {\n                        checksum,\n                        size: assetData.byteLength,\n                        type: assetType,\n                        critical: isCritical,\n                        lastModified: asset.lastModified || new Date().toISOString(),\n                        downloadUrl: asset.downloadUrl || \n                            (this.config.enableCDN ? \n                                `${this.config.cdnBaseUrl}${asset.path}` : \n                                `${this.config.baseUrl}${asset.path}`)\n                    };\n                    \n                    this.stats.processed++;\n                    this.stats.totalSize += assetData.byteLength;\n                    \n                } catch (error) {\n                    console.error(`Failed to process asset ${asset.path}:`, error);\n                    this.stats.errors++;\n                }\n            }\n            \n            // Update metadata\n            this.manifest.generated = new Date().toISOString();\n            this.manifest.metadata.totalAssets = this.stats.processed;\n            this.manifest.metadata.totalSize = this.stats.totalSize;\n            \n            console.log('Manifest generation completed:', this.stats);\n            return this.manifest;\n            \n        } catch (error) {\n            console.error('Failed to generate manifest from asset list:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Find files matching patterns\n     */\n    async findFiles(rootPath) {\n        if (typeof require === 'undefined') {\n            throw new Error('findFiles requires Node.js environment');\n        }\n        \n        const glob = require('glob');\n        const path = require('path');\n        \n        const allFiles = new Set();\n        \n        // Add files matching include patterns\n        for (const pattern of this.config.includePatterns) {\n            const files = await new Promise((resolve, reject) => {\n                glob(pattern, { cwd: rootPath, absolute: true }, (err, matches) => {\n                    if (err) reject(err);\n                    else resolve(matches);\n                });\n            });\n            \n            files.forEach(file => allFiles.add(file));\n        }\n        \n        // Remove files matching exclude patterns\n        for (const pattern of this.config.excludePatterns) {\n            const filesToExclude = await new Promise((resolve, reject) => {\n                glob(pattern, { cwd: rootPath, absolute: true }, (err, matches) => {\n                    if (err) reject(err);\n                    else resolve(matches);\n                });\n            });\n            \n            filesToExclude.forEach(file => allFiles.delete(file));\n        }\n        \n        return Array.from(allFiles);\n    }\n    \n    /**\n     * Calculate checksum for asset data\n     */\n    async calculateChecksum(data) {\n        if (typeof require !== 'undefined') {\n            // Node.js environment\n            const crypto = require('crypto');\n            const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n            return crypto.createHash('sha256').update(buffer).digest('hex');\n        } else {\n            // Browser environment\n            if (window.crypto && window.crypto.subtle) {\n                const arrayBuffer = data instanceof ArrayBuffer ? data : data.buffer;\n                const hashBuffer = await window.crypto.subtle.digest('SHA-256', arrayBuffer);\n                const hashArray = Array.from(new Uint8Array(hashBuffer));\n                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n            } else {\n                // Fallback to simple hash\n                return this.calculateSimpleHash(data);\n            }\n        }\n    }\n    \n    /**\n     * Calculate simple hash (fallback)\n     */\n    calculateSimpleHash(data) {\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        let hash = 0;\n        \n        for (let i = 0; i < bytes.length; i++) {\n            hash = ((hash << 5) - hash + bytes[i]) & 0xffffffff;\n        }\n        \n        return hash.toString(16);\n    }\n    \n    /**\n     * Get asset type from file path\n     */\n    getAssetType(filePath) {\n        const ext = filePath.split('.').pop().toLowerCase();\n        \n        const typeMap = {\n            // Scripts\n            'js': 'script',\n            'mjs': 'script',\n            'ts': 'script',\n            \n            // Styles\n            'css': 'style',\n            'scss': 'style',\n            'sass': 'style',\n            'less': 'style',\n            \n            // Images\n            'png': 'image',\n            'jpg': 'image',\n            'jpeg': 'image',\n            'gif': 'image',\n            'webp': 'image',\n            'svg': 'image',\n            'ico': 'image',\n            \n            // Audio\n            'mp3': 'audio',\n            'wav': 'audio',\n            'ogg': 'audio',\n            'aac': 'audio',\n            'm4a': 'audio',\n            \n            // Video\n            'mp4': 'video',\n            'webm': 'video',\n            'ogv': 'video',\n            'avi': 'video',\n            'mov': 'video',\n            \n            // Fonts\n            'woff': 'font',\n            'woff2': 'font',\n            'ttf': 'font',\n            'otf': 'font',\n            'eot': 'font',\n            \n            // Data\n            'json': 'data',\n            'xml': 'data',\n            'csv': 'data',\n            'txt': 'data',\n            \n            // Documents\n            'html': 'document',\n            'htm': 'document',\n            'pdf': 'document',\n            \n            // Models\n            'gltf': 'model',\n            'glb': 'model',\n            'obj': 'model',\n            'fbx': 'model'\n        };\n        \n        return typeMap[ext] || 'unknown';\n    }\n    \n    /**\n     * Add asset to manifest\n     */\n    addAsset(path, assetInfo) {\n        this.manifest.assets[path] = {\n            checksum: assetInfo.checksum,\n            size: assetInfo.size,\n            type: assetInfo.type || this.getAssetType(path),\n            critical: assetInfo.critical || false,\n            lastModified: assetInfo.lastModified || new Date().toISOString(),\n            downloadUrl: assetInfo.downloadUrl || \n                (this.config.enableCDN ? \n                    `${this.config.cdnBaseUrl}${path}` : \n                    `${this.config.baseUrl}${path}`)\n        };\n        \n        this.manifest.metadata.totalAssets++;\n        this.manifest.metadata.totalSize += assetInfo.size;\n    }\n    \n    /**\n     * Remove asset from manifest\n     */\n    removeAsset(path) {\n        if (this.manifest.assets[path]) {\n            this.manifest.metadata.totalSize -= this.manifest.assets[path].size;\n            this.manifest.metadata.totalAssets--;\n            delete this.manifest.assets[path];\n        }\n    }\n    \n    /**\n     * Update asset in manifest\n     */\n    updateAsset(path, assetInfo) {\n        if (this.manifest.assets[path]) {\n            this.removeAsset(path);\n        }\n        this.addAsset(path, assetInfo);\n    }\n    \n    /**\n     * Set manifest version\n     */\n    setVersion(version) {\n        this.manifest.version = version;\n    }\n    \n    /**\n     * Get manifest\n     */\n    getManifest() {\n        return { ...this.manifest };\n    }\n    \n    /**\n     * Export manifest to JSON string\n     */\n    exportManifest(pretty = true) {\n        return JSON.stringify(this.manifest, null, pretty ? 2 : 0);\n    }\n    \n    /**\n     * Save manifest to file (Node.js environment)\n     */\n    async saveManifest(outputPath) {\n        if (typeof require === 'undefined') {\n            throw new Error('saveManifest requires Node.js environment');\n        }\n        \n        const fs = require('fs').promises;\n        const path = require('path');\n        \n        try {\n            const manifestJson = this.exportManifest(true);\n            const fullPath = outputPath || this.config.outputPath;\n            \n            // Ensure directory exists\n            const dir = path.dirname(fullPath);\n            await fs.mkdir(dir, { recursive: true });\n            \n            // Write manifest file\n            await fs.writeFile(fullPath, manifestJson, 'utf8');\n            \n            console.log(`Manifest saved to: ${fullPath}`);\n            return fullPath;\n            \n        } catch (error) {\n            console.error('Failed to save manifest:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Load manifest from file (Node.js environment)\n     */\n    async loadManifest(inputPath) {\n        if (typeof require === 'undefined') {\n            throw new Error('loadManifest requires Node.js environment');\n        }\n        \n        const fs = require('fs').promises;\n        \n        try {\n            const fullPath = inputPath || this.config.outputPath;\n            const manifestJson = await fs.readFile(fullPath, 'utf8');\n            const manifest = JSON.parse(manifestJson);\n            \n            // Validate manifest\n            this.validateManifest(manifest);\n            \n            this.manifest = manifest;\n            console.log(`Manifest loaded from: ${fullPath}`);\n            \n            return manifest;\n            \n        } catch (error) {\n            console.error('Failed to load manifest:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Validate manifest structure\n     */\n    validateManifest(manifest) {\n        if (!manifest || typeof manifest !== 'object') {\n            throw new Error('Invalid manifest: not an object');\n        }\n        \n        if (!manifest.assets || typeof manifest.assets !== 'object') {\n            throw new Error('Invalid manifest: missing assets object');\n        }\n        \n        // Validate each asset entry\n        for (const [path, asset] of Object.entries(manifest.assets)) {\n            if (!asset.checksum) {\n                throw new Error(`Invalid manifest: asset ${path} missing checksum`);\n            }\n            \n            if (!asset.size || typeof asset.size !== 'number') {\n                throw new Error(`Invalid manifest: asset ${path} missing or invalid size`);\n            }\n            \n            if (!asset.type) {\n                throw new Error(`Invalid manifest: asset ${path} missing type`);\n            }\n        }\n    }\n    \n    /**\n     * Compare two manifests\n     */\n    compareManifests(otherManifest) {\n        const comparison = {\n            added: [],\n            removed: [],\n            modified: [],\n            unchanged: []\n        };\n        \n        const currentAssets = new Set(Object.keys(this.manifest.assets));\n        const otherAssets = new Set(Object.keys(otherManifest.assets));\n        \n        // Find added assets\n        for (const asset of currentAssets) {\n            if (!otherAssets.has(asset)) {\n                comparison.added.push(asset);\n            }\n        }\n        \n        // Find removed assets\n        for (const asset of otherAssets) {\n            if (!currentAssets.has(asset)) {\n                comparison.removed.push(asset);\n            }\n        }\n        \n        // Find modified and unchanged assets\n        for (const asset of currentAssets) {\n            if (otherAssets.has(asset)) {\n                const currentAsset = this.manifest.assets[asset];\n                const otherAsset = otherManifest.assets[asset];\n                \n                if (currentAsset.checksum !== otherAsset.checksum) {\n                    comparison.modified.push(asset);\n                } else {\n                    comparison.unchanged.push(asset);\n                }\n            }\n        }\n        \n        return comparison;\n    }\n    \n    /**\n     * Get statistics\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            manifest: {\n                version: this.manifest.version,\n                totalAssets: this.manifest.metadata.totalAssets,\n                totalSize: this.manifest.metadata.totalSize,\n                generated: this.manifest.generated\n            }\n        };\n    }\n    \n    /**\n     * Reset generator\n     */\n    reset() {\n        this.manifest = {\n            version: '1.0.0',\n            generated: null,\n            assets: {},\n            metadata: {\n                totalAssets: 0,\n                totalSize: 0,\n                compressionEnabled: this.config.enableCompression,\n                cdnEnabled: this.config.enableCDN\n            }\n        };\n        \n        this.stats = {\n            processed: 0,\n            skipped: 0,\n            errors: 0,\n            totalSize: 0\n        };\n    }\n}\n\nexport default AssetManifestGenerator;"