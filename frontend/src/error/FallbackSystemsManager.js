/**\n * Fallback Systems Manager\n * Manages fallback systems for critical game components\n */\nclass FallbackSystemsManager {\n    constructor(gameEngine) {\n        this.gameEngine = gameEngine;\n        \n        // Fallback systems registry\n        this.fallbackSystems = new Map();\n        this.activeFallbacks = new Map();\n        \n        // Configuration\n        this.config = {\n            enableFallbacks: true,\n            autoActivation: true,\n            fallbackTimeout: 10000, // 10 seconds\n            maxActivationAttempts: 3,\n            debugMode: process.env.NODE_ENV === 'development'\n        };\n        \n        // State tracking\n        this.activationAttempts = new Map();\n        this.fallbackMetrics = {\n            activations: 0,\n            failures: 0,\n            recoveries: 0\n        };\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialize fallback systems\n     */\n    initialize() {\n        console.log('Initializing Fallback Systems Manager...');\n        \n        this.registerDefaultFallbacks();\n        this.setupEventListeners();\n        \n        console.log('Fallback Systems Manager initialized');\n    }\n    \n    /**\n     * Register default fallback systems\n     */\n    registerDefaultFallbacks() {\n        // Rendering fallback\n        this.registerFallback('rendering', {\n            name: 'Canvas 2D Renderer',\n            priority: 1,\n            requirements: ['canvas'],\n            initialize: this.initializeCanvas2DFallback.bind(this),\n            cleanup: this.cleanupCanvas2DFallback.bind(this),\n            healthCheck: this.checkCanvas2DHealth.bind(this)\n        });\n        \n        // Audio fallback\n        this.registerFallback('audio', {\n            name: 'Silent Audio System',\n            priority: 1,\n            requirements: [],\n            initialize: this.initializeSilentAudioFallback.bind(this),\n            cleanup: this.cleanupSilentAudioFallback.bind(this),\n            healthCheck: this.checkSilentAudioHealth.bind(this)\n        });\n        \n        // Network fallback\n        this.registerFallback('network', {\n            name: 'Offline Mode',\n            priority: 1,\n            requirements: ['localStorage'],\n            initialize: this.initializeOfflineModeFallback.bind(this),\n            cleanup: this.cleanupOfflineModeFallback.bind(this),\n            healthCheck: this.checkOfflineModeHealth.bind(this)\n        });\n        \n        // Storage fallback\n        this.registerFallback('storage', {\n            name: 'Memory Storage',\n            priority: 1,\n            requirements: [],\n            initialize: this.initializeMemoryStorageFallback.bind(this),\n            cleanup: this.cleanupMemoryStorageFallback.bind(this),\n            healthCheck: this.checkMemoryStorageHealth.bind(this)\n        });\n        \n        // Input fallback\n        this.registerFallback('input', {\n            name: 'Basic Input Handler',\n            priority: 1,\n            requirements: [],\n            initialize: this.initializeBasicInputFallback.bind(this),\n            cleanup: this.cleanupBasicInputFallback.bind(this),\n            healthCheck: this.checkBasicInputHealth.bind(this)\n        });\n        \n        // Physics fallback\n        this.registerFallback('physics', {\n            name: 'Simple Physics',\n            priority: 1,\n            requirements: [],\n            initialize: this.initializeSimplePhysicsFallback.bind(this),\n            cleanup: this.cleanupSimplePhysicsFallback.bind(this),\n            healthCheck: this.checkSimplePhysicsHealth.bind(this)\n        });\n    }\n    \n    /**\n     * Register a fallback system\n     */\n    registerFallback(systemType, fallbackConfig) {\n        if (!this.fallbackSystems.has(systemType)) {\n            this.fallbackSystems.set(systemType, []);\n        }\n        \n        const fallbacks = this.fallbackSystems.get(systemType);\n        fallbacks.push({\n            ...fallbackConfig,\n            id: this.generateId(),\n            systemType,\n            registered: Date.now(),\n            active: false,\n            instance: null\n        });\n        \n        // Sort by priority (higher priority first)\n        fallbacks.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n        \n        if (this.config.debugMode) {\n            console.log(`Registered fallback for ${systemType}: ${fallbackConfig.name}`);\n        }\n    }\n    \n    /**\n     * Activate fallback system\n     */\n    async activateFallback(systemType, reason = 'unknown') {\n        if (!this.config.enableFallbacks) {\n            console.log('Fallbacks disabled, skipping activation');\n            return false;\n        }\n        \n        const fallbacks = this.fallbackSystems.get(systemType);\n        if (!fallbacks || fallbacks.length === 0) {\n            console.warn(`No fallback systems registered for: ${systemType}`);\n            return false;\n        }\n        \n        // Check if already active\n        if (this.activeFallbacks.has(systemType)) {\n            console.log(`Fallback already active for: ${systemType}`);\n            return true;\n        }\n        \n        // Check activation attempts\n        const attempts = this.activationAttempts.get(systemType) || 0;\n        if (attempts >= this.config.maxActivationAttempts) {\n            console.error(`Max activation attempts reached for: ${systemType}`);\n            return false;\n        }\n        \n        this.activationAttempts.set(systemType, attempts + 1);\n        \n        console.log(`Activating fallback for ${systemType} (reason: ${reason})`);\n        \n        // Try each fallback in priority order\n        for (const fallback of fallbacks) {\n            try {\n                // Check requirements\n                if (!this.checkRequirements(fallback.requirements)) {\n                    console.warn(`Requirements not met for fallback: ${fallback.name}`);\n                    continue;\n                }\n                \n                // Initialize fallback\n                const instance = await this.initializeFallback(fallback);\n                \n                if (instance) {\n                    // Mark as active\n                    fallback.active = true;\n                    fallback.instance = instance;\n                    fallback.activatedAt = Date.now();\n                    fallback.activationReason = reason;\n                    \n                    this.activeFallbacks.set(systemType, fallback);\n                    this.fallbackMetrics.activations++;\n                    \n                    // Notify game engine\n                    if (this.gameEngine.onFallbackActivated) {\n                        this.gameEngine.onFallbackActivated(systemType, fallback, instance);\n                    }\n                    \n                    console.log(`Fallback activated: ${fallback.name}`);\n                    \n                    // Start health monitoring\n                    this.startHealthMonitoring(fallback);\n                    \n                    return true;\n                }\n                \n            } catch (error) {\n                console.error(`Failed to activate fallback ${fallback.name}:`, error);\n                this.fallbackMetrics.failures++;\n                continue;\n            }\n        }\n        \n        console.error(`All fallback systems failed for: ${systemType}`);\n        return false;\n    }\n    \n    /**\n     * Deactivate fallback system\n     */\n    async deactivateFallback(systemType, reason = 'recovery') {\n        const activeFallback = this.activeFallbacks.get(systemType);\n        if (!activeFallback) {\n            console.log(`No active fallback for: ${systemType}`);\n            return true;\n        }\n        \n        console.log(`Deactivating fallback for ${systemType} (reason: ${reason})`);\n        \n        try {\n            // Stop health monitoring\n            this.stopHealthMonitoring(activeFallback);\n            \n            // Cleanup fallback\n            if (activeFallback.cleanup) {\n                await activeFallback.cleanup(activeFallback.instance);\n            }\n            \n            // Mark as inactive\n            activeFallback.active = false;\n            activeFallback.instance = null;\n            activeFallback.deactivatedAt = Date.now();\n            activeFallback.deactivationReason = reason;\n            \n            this.activeFallbacks.delete(systemType);\n            \n            if (reason === 'recovery') {\n                this.fallbackMetrics.recoveries++;\n                // Reset activation attempts on successful recovery\n                this.activationAttempts.delete(systemType);\n            }\n            \n            // Notify game engine\n            if (this.gameEngine.onFallbackDeactivated) {\n                this.gameEngine.onFallbackDeactivated(systemType, activeFallback, reason);\n            }\n            \n            console.log(`Fallback deactivated: ${activeFallback.name}`);\n            return true;\n            \n        } catch (error) {\n            console.error(`Failed to deactivate fallback ${activeFallback.name}:`, error);\n            return false;\n        }\n    }\n    \n    /**\n     * Initialize fallback with timeout\n     */\n    async initializeFallback(fallback) {\n        return new Promise(async (resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error(`Fallback initialization timeout: ${fallback.name}`));\n            }, this.config.fallbackTimeout);\n            \n            try {\n                const instance = await fallback.initialize();\n                clearTimeout(timeout);\n                resolve(instance);\n            } catch (error) {\n                clearTimeout(timeout);\n                reject(error);\n            }\n        });\n    }\n    \n    /**\n     * Check requirements\n     */\n    checkRequirements(requirements) {\n        if (!requirements || requirements.length === 0) {\n            return true;\n        }\n        \n        for (const requirement of requirements) {\n            switch (requirement) {\n                case 'canvas':\n                    if (!document.createElement('canvas').getContext) {\n                        return false;\n                    }\n                    break;\n                case 'webgl':\n                    const canvas = document.createElement('canvas');\n                    if (!canvas.getContext('webgl') && !canvas.getContext('experimental-webgl')) {\n                        return false;\n                    }\n                    break;\n                case 'localStorage':\n                    if (typeof Storage === 'undefined' || !localStorage) {\n                        return false;\n                    }\n                    break;\n                case 'indexedDB':\n                    if (!window.indexedDB) {\n                        return false;\n                    }\n                    break;\n                case 'webAudio':\n                    if (!window.AudioContext && !window.webkitAudioContext) {\n                        return false;\n                    }\n                    break;\n                default:\n                    console.warn(`Unknown requirement: ${requirement}`);\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Start health monitoring\n     */\n    startHealthMonitoring(fallback) {\n        if (!fallback.healthCheck) return;\n        \n        const healthCheckInterval = setInterval(async () => {\n            try {\n                const isHealthy = await fallback.healthCheck(fallback.instance);\n                \n                if (!isHealthy) {\n                    console.warn(`Fallback health check failed: ${fallback.name}`);\n                    clearInterval(healthCheckInterval);\n                    \n                    // Try to reactivate or switch to another fallback\n                    await this.handleFallbackFailure(fallback.systemType, 'health_check_failed');\n                }\n            } catch (error) {\n                console.error(`Health check error for ${fallback.name}:`, error);\n                clearInterval(healthCheckInterval);\n                await this.handleFallbackFailure(fallback.systemType, 'health_check_error');\n            }\n        }, 30000); // Check every 30 seconds\n        \n        fallback.healthCheckInterval = healthCheckInterval;\n    }\n    \n    /**\n     * Stop health monitoring\n     */\n    stopHealthMonitoring(fallback) {\n        if (fallback.healthCheckInterval) {\n            clearInterval(fallback.healthCheckInterval);\n            delete fallback.healthCheckInterval;\n        }\n    }\n    \n    /**\n     * Handle fallback failure\n     */\n    async handleFallbackFailure(systemType, reason) {\n        console.log(`Handling fallback failure for ${systemType}: ${reason}`);\n        \n        // Deactivate current fallback\n        await this.deactivateFallback(systemType, 'failure');\n        \n        // Try to activate another fallback\n        const activated = await this.activateFallback(systemType, `fallback_failure_${reason}`);\n        \n        if (!activated) {\n            console.error(`No working fallback available for: ${systemType}`);\n            \n            // Notify game engine of complete failure\n            if (this.gameEngine.onFallbackSystemFailure) {\n                this.gameEngine.onFallbackSystemFailure(systemType, reason);\n            }\n        }\n    }\n    \n    /**\n     * Setup event listeners\n     */\n    setupEventListeners() {\n        // Listen for system failures\n        window.addEventListener('error', (event) => {\n            if (this.config.autoActivation) {\n                this.handleSystemError(event);\n            }\n        });\n        \n        // Listen for WebGL context loss\n        window.addEventListener('webglcontextlost', () => {\n            if (this.config.autoActivation) {\n                this.activateFallback('rendering', 'webgl_context_lost');\n            }\n        });\n        \n        // Listen for WebGL context restore\n        window.addEventListener('webglcontextrestored', () => {\n            this.deactivateFallback('rendering', 'webgl_context_restored');\n        });\n    }\n    \n    /**\n     * Handle system error\n     */\n    handleSystemError(event) {\n        const filename = event.filename || '';\n        \n        // Determine system type from error\n        let systemType = 'general';\n        \n        if (filename.includes('audio') || event.message?.includes('audio')) {\n            systemType = 'audio';\n        } else if (filename.includes('render') || event.message?.includes('webgl')) {\n            systemType = 'rendering';\n        } else if (filename.includes('network') || event.message?.includes('fetch')) {\n            systemType = 'network';\n        } else if (filename.includes('storage') || event.message?.includes('storage')) {\n            systemType = 'storage';\n        }\n        \n        if (systemType !== 'general') {\n            this.activateFallback(systemType, 'javascript_error');\n        }\n    }\n    \n    // Fallback system implementations\n    \n    /**\n     * Canvas 2D Fallback\n     */\n    async initializeCanvas2DFallback() {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        if (!ctx) {\n            throw new Error('Canvas 2D not available');\n        }\n        \n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        canvas.id = 'fallback-canvas';\n        \n        // Replace main canvas\n        const mainCanvas = document.querySelector('#game-canvas');\n        if (mainCanvas && mainCanvas.parentNode) {\n            mainCanvas.parentNode.replaceChild(canvas, mainCanvas);\n        } else {\n            document.body.appendChild(canvas);\n        }\n        \n        return {\n            canvas,\n            context: ctx,\n            type: '2d',\n            clear: () => ctx.clearRect(0, 0, canvas.width, canvas.height),\n            drawRect: (x, y, w, h, color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(x, y, w, h);\n            },\n            drawText: (text, x, y, color, size) => {\n                ctx.fillStyle = color;\n                ctx.font = `${size}px Arial`;\n                ctx.fillText(text, x, y);\n            }\n        };\n    }\n    \n    async cleanupCanvas2DFallback(instance) {\n        if (instance.canvas && instance.canvas.parentNode) {\n            instance.canvas.parentNode.removeChild(instance.canvas);\n        }\n    }\n    \n    async checkCanvas2DHealth(instance) {\n        return instance.canvas && instance.context && !instance.canvas.isContextLost?.();\n    }\n    \n    /**\n     * Silent Audio Fallback\n     */\n    async initializeSilentAudioFallback() {\n        return {\n            type: 'silent',\n            play: () => Promise.resolve(),\n            pause: () => {},\n            stop: () => {},\n            setVolume: () => {},\n            isPlaying: () => false,\n            createSound: () => ({\n                play: () => Promise.resolve(),\n                pause: () => {},\n                stop: () => {}\n            })\n        };\n    }\n    \n    async cleanupSilentAudioFallback(instance) {\n        // Nothing to cleanup for silent audio\n    }\n    \n    async checkSilentAudioHealth(instance) {\n        return true; // Silent audio is always \"healthy\"\n    }\n    \n    /**\n     * Offline Mode Fallback\n     */\n    async initializeOfflineModeFallback() {\n        return {\n            type: 'offline',\n            isOnline: false,\n            fetch: async (url, options) => {\n                // Return cached data or mock response\n                const cached = localStorage.getItem(`cache_${url}`);\n                if (cached) {\n                    return {\n                        ok: true,\n                        json: () => Promise.resolve(JSON.parse(cached))\n                    };\n                }\n                throw new Error('Offline: No cached data available');\n            },\n            save: (key, data) => {\n                localStorage.setItem(`offline_${key}`, JSON.stringify(data));\n            },\n            load: (key) => {\n                const data = localStorage.getItem(`offline_${key}`);\n                return data ? JSON.parse(data) : null;\n            }\n        };\n    }\n    \n    async cleanupOfflineModeFallback(instance) {\n        // Cleanup offline data if needed\n    }\n    \n    async checkOfflineModeHealth(instance) {\n        return typeof Storage !== 'undefined' && localStorage;\n    }\n    \n    /**\n     * Memory Storage Fallback\n     */\n    async initializeMemoryStorageFallback() {\n        const storage = new Map();\n        \n        return {\n            type: 'memory',\n            get: (key) => storage.get(key),\n            set: (key, value) => storage.set(key, value),\n            remove: (key) => storage.delete(key),\n            clear: () => storage.clear(),\n            keys: () => Array.from(storage.keys()),\n            size: () => storage.size\n        };\n    }\n    \n    async cleanupMemoryStorageFallback(instance) {\n        instance.clear();\n    }\n    \n    async checkMemoryStorageHealth(instance) {\n        return instance && typeof instance.get === 'function';\n    }\n    \n    /**\n     * Basic Input Fallback\n     */\n    async initializeBasicInputFallback() {\n        const inputState = {\n            keys: new Set(),\n            mouse: { x: 0, y: 0, buttons: 0 }\n        };\n        \n        const keyHandler = (e) => {\n            if (e.type === 'keydown') {\n                inputState.keys.add(e.code);\n            } else {\n                inputState.keys.delete(e.code);\n            }\n        };\n        \n        const mouseHandler = (e) => {\n            inputState.mouse.x = e.clientX;\n            inputState.mouse.y = e.clientY;\n            inputState.mouse.buttons = e.buttons;\n        };\n        \n        document.addEventListener('keydown', keyHandler);\n        document.addEventListener('keyup', keyHandler);\n        document.addEventListener('mousemove', mouseHandler);\n        document.addEventListener('mousedown', mouseHandler);\n        document.addEventListener('mouseup', mouseHandler);\n        \n        return {\n            type: 'basic',\n            isKeyPressed: (key) => inputState.keys.has(key),\n            getMousePosition: () => ({ ...inputState.mouse }),\n            cleanup: () => {\n                document.removeEventListener('keydown', keyHandler);\n                document.removeEventListener('keyup', keyHandler);\n                document.removeEventListener('mousemove', mouseHandler);\n                document.removeEventListener('mousedown', mouseHandler);\n                document.removeEventListener('mouseup', mouseHandler);\n            }\n        };\n    }\n    \n    async cleanupBasicInputFallback(instance) {\n        if (instance.cleanup) {\n            instance.cleanup();\n        }\n    }\n    \n    async checkBasicInputHealth(instance) {\n        return instance && typeof instance.isKeyPressed === 'function';\n    }\n    \n    /**\n     * Simple Physics Fallback\n     */\n    async initializeSimplePhysicsFallback() {\n        return {\n            type: 'simple',\n            bodies: new Map(),\n            addBody: (id, body) => {\n                this.bodies.set(id, {\n                    ...body,\n                    velocity: body.velocity || { x: 0, y: 0 },\n                    acceleration: body.acceleration || { x: 0, y: 0 }\n                });\n            },\n            removeBody: (id) => this.bodies.delete(id),\n            update: (deltaTime) => {\n                this.bodies.forEach(body => {\n                    // Simple physics integration\n                    body.velocity.x += body.acceleration.x * deltaTime;\n                    body.velocity.y += body.acceleration.y * deltaTime;\n                    body.position.x += body.velocity.x * deltaTime;\n                    body.position.y += body.velocity.y * deltaTime;\n                });\n            },\n            checkCollision: (body1, body2) => {\n                // Simple AABB collision\n                return body1.position.x < body2.position.x + body2.width &&\n                       body1.position.x + body1.width > body2.position.x &&\n                       body1.position.y < body2.position.y + body2.height &&\n                       body1.position.y + body1.height > body2.position.y;\n            }\n        };\n    }\n    \n    async cleanupSimplePhysicsFallback(instance) {\n        if (instance.bodies) {\n            instance.bodies.clear();\n        }\n    }\n    \n    async checkSimplePhysicsHealth(instance) {\n        return instance && typeof instance.update === 'function';\n    }\n    \n    /**\n     * Generate unique ID\n     */\n    generateId() {\n        return Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    }\n    \n    /**\n     * Get active fallbacks\n     */\n    getActiveFallbacks() {\n        const active = {};\n        this.activeFallbacks.forEach((fallback, systemType) => {\n            active[systemType] = {\n                name: fallback.name,\n                activatedAt: fallback.activatedAt,\n                reason: fallback.activationReason\n            };\n        });\n        return active;\n    }\n    \n    /**\n     * Get fallback metrics\n     */\n    getMetrics() {\n        return {\n            ...this.fallbackMetrics,\n            activeFallbacks: this.activeFallbacks.size,\n            registeredSystems: this.fallbackSystems.size,\n            activationAttempts: Object.fromEntries(this.activationAttempts)\n        };\n    }\n    \n    /**\n     * Update configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        console.log('Fallback systems configuration updated:', this.config);\n    }\n    \n    /**\n     * Cleanup and destroy\n     */\n    async destroy() {\n        // Deactivate all fallbacks\n        const deactivationPromises = [];\n        this.activeFallbacks.forEach((fallback, systemType) => {\n            deactivationPromises.push(this.deactivateFallback(systemType, 'shutdown'));\n        });\n        \n        await Promise.allSettled(deactivationPromises);\n        \n        // Clear data\n        this.fallbackSystems.clear();\n        this.activeFallbacks.clear();\n        this.activationAttempts.clear();\n        \n        console.log('Fallback Systems Manager destroyed');\n    }\n}\n\nexport default FallbackSystemsManager;"