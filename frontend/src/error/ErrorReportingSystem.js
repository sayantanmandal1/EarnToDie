/**\n * Error Reporting and Logging System\n * Handles error reporting, logging, and analytics\n */\nclass ErrorReportingSystem {\n    constructor(config = {}) {\n        this.config = {\n            reportingEndpoint: '/api/errors',\n            analyticsEndpoint: '/api/analytics',\n            maxQueueSize: 100,\n            batchSize: 10,\n            reportingInterval: 60000, // 1 minute\n            retryAttempts: 3,\n            retryDelay: 5000,\n            enableConsoleLogging: true,\n            enableRemoteLogging: true,\n            enableAnalytics: true,\n            logLevel: 'info', // 'debug', 'info', 'warn', 'error'\n            userConsent: true,\n            debugMode: process.env.NODE_ENV === 'development',\n            ...config\n        };\n        \n        // Queues\n        this.errorQueue = [];\n        this.logQueue = [];\n        this.analyticsQueue = [];\n        \n        // State\n        this.sessionId = this.generateSessionId();\n        this.userId = this.getUserId();\n        this.reportingInterval = null;\n        this.retryTimeouts = new Map();\n        \n        // Metrics\n        this.metrics = {\n            errorsReported: 0,\n            logsGenerated: 0,\n            analyticsEvents: 0,\n            reportingFailures: 0,\n            lastReportTime: null\n        };\n        \n        // Log levels\n        this.logLevels = {\n            debug: 0,\n            info: 1,\n            warn: 2,\n            error: 3\n        };\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialize reporting system\n     */\n    initialize() {\n        console.log('Initializing Error Reporting System...');\n        \n        this.setupConsoleLogging();\n        this.startReportingInterval();\n        this.setupEventListeners();\n        \n        // Log system start\n        this.log('info', 'Error Reporting System initialized', {\n            sessionId: this.sessionId,\n            userId: this.userId,\n            config: this.config\n        });\n        \n        console.log('Error Reporting System initialized');\n    }\n    \n    /**\n     * Setup console logging enhancement\n     */\n    setupConsoleLogging() {\n        if (!this.config.enableConsoleLogging) return;\n        \n        // Store original console methods\n        this.originalConsole = {\n            log: console.log,\n            info: console.info,\n            warn: console.warn,\n            error: console.error,\n            debug: console.debug\n        };\n        \n        // Enhance console methods\n        console.log = (...args) => {\n            this.originalConsole.log(...args);\n            this.log('info', this.formatConsoleMessage(args));\n        };\n        \n        console.info = (...args) => {\n            this.originalConsole.info(...args);\n            this.log('info', this.formatConsoleMessage(args));\n        };\n        \n        console.warn = (...args) => {\n            this.originalConsole.warn(...args);\n            this.log('warn', this.formatConsoleMessage(args));\n        };\n        \n        console.error = (...args) => {\n            this.originalConsole.error(...args);\n            this.log('error', this.formatConsoleMessage(args));\n            \n            // Also report as error\n            this.reportError({\n                type: 'console_error',\n                message: this.formatConsoleMessage(args),\n                severity: 'medium',\n                source: 'console'\n            });\n        };\n        \n        console.debug = (...args) => {\n            this.originalConsole.debug(...args);\n            if (this.config.debugMode) {\n                this.log('debug', this.formatConsoleMessage(args));\n            }\n        };\n    }\n    \n    /**\n     * Format console message\n     */\n    formatConsoleMessage(args) {\n        return args.map(arg => {\n            if (typeof arg === 'object') {\n                try {\n                    return JSON.stringify(arg, null, 2);\n                } catch (e) {\n                    return '[Object]';\n                }\n            }\n            return String(arg);\n        }).join(' ');\n    }\n    \n    /**\n     * Start reporting interval\n     */\n    startReportingInterval() {\n        if (this.reportingInterval) {\n            clearInterval(this.reportingInterval);\n        }\n        \n        this.reportingInterval = setInterval(() => {\n            this.sendQueuedReports();\n        }, this.config.reportingInterval);\n    }\n    \n    /**\n     * Setup event listeners\n     */\n    setupEventListeners() {\n        // Send reports before page unload\n        window.addEventListener('beforeunload', () => {\n            this.sendQueuedReports(true); // Synchronous\n        });\n        \n        // Send reports when going offline\n        window.addEventListener('offline', () => {\n            this.log('warn', 'Device went offline');\n        });\n        \n        // Resume reporting when back online\n        window.addEventListener('online', () => {\n            this.log('info', 'Device back online');\n            this.sendQueuedReports();\n        });\n    }\n    \n    /**\n     * Report an error\n     */\n    reportError(errorInfo) {\n        try {\n            const report = {\n                id: this.generateId(),\n                timestamp: Date.now(),\n                sessionId: this.sessionId,\n                userId: this.userId,\n                type: errorInfo.type || 'unknown',\n                message: errorInfo.message || 'No message',\n                severity: errorInfo.severity || 'medium',\n                category: errorInfo.category || 'general',\n                source: errorInfo.source || 'unknown',\n                stack: errorInfo.stack,\n                url: window.location.href,\n                userAgent: navigator.userAgent,\n                viewport: {\n                    width: window.innerWidth,\n                    height: window.innerHeight\n                },\n                gameState: errorInfo.gameState,\n                additionalData: errorInfo.data\n            };\n            \n            // Add to queue\n            this.errorQueue.push(report);\n            \n            // Limit queue size\n            if (this.errorQueue.length > this.config.maxQueueSize) {\n                this.errorQueue.shift();\n            }\n            \n            this.metrics.errorsReported++;\n            \n            // Log locally\n            this.log('error', `Error reported: ${report.type}`, report);\n            \n            // Send immediately for critical errors\n            if (errorInfo.severity === 'critical') {\n                this.sendErrorReport(report);\n            }\n            \n            return report.id;\n            \n        } catch (error) {\n            console.error('Failed to report error:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Log a message\n     */\n    log(level, message, data = null) {\n        try {\n            // Check log level\n            if (this.logLevels[level] < this.logLevels[this.config.logLevel]) {\n                return;\n            }\n            \n            const logEntry = {\n                id: this.generateId(),\n                timestamp: Date.now(),\n                sessionId: this.sessionId,\n                userId: this.userId,\n                level,\n                message,\n                data,\n                url: window.location.href,\n                stack: level === 'error' ? new Error().stack : null\n            };\n            \n            // Add to queue\n            this.logQueue.push(logEntry);\n            \n            // Limit queue size\n            if (this.logQueue.length > this.config.maxQueueSize) {\n                this.logQueue.shift();\n            }\n            \n            this.metrics.logsGenerated++;\n            \n            return logEntry.id;\n            \n        } catch (error) {\n            console.error('Failed to log message:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Track analytics event\n     */\n    trackEvent(eventName, properties = {}) {\n        try {\n            if (!this.config.enableAnalytics || !this.config.userConsent) {\n                return;\n            }\n            \n            const event = {\n                id: this.generateId(),\n                timestamp: Date.now(),\n                sessionId: this.sessionId,\n                userId: this.userId,\n                eventName,\n                properties: {\n                    ...properties,\n                    url: window.location.href,\n                    userAgent: navigator.userAgent,\n                    viewport: {\n                        width: window.innerWidth,\n                        height: window.innerHeight\n                    }\n                }\n            };\n            \n            // Add to queue\n            this.analyticsQueue.push(event);\n            \n            // Limit queue size\n            if (this.analyticsQueue.length > this.config.maxQueueSize) {\n                this.analyticsQueue.shift();\n            }\n            \n            this.metrics.analyticsEvents++;\n            \n            return event.id;\n            \n        } catch (error) {\n            console.error('Failed to track event:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Send queued reports\n     */\n    async sendQueuedReports(synchronous = false) {\n        try {\n            const promises = [];\n            \n            // Send error reports\n            if (this.errorQueue.length > 0) {\n                const batch = this.errorQueue.splice(0, this.config.batchSize);\n                const promise = this.sendErrorBatch(batch);\n                \n                if (synchronous) {\n                    await promise;\n                } else {\n                    promises.push(promise);\n                }\n            }\n            \n            // Send logs\n            if (this.logQueue.length > 0 && this.config.enableRemoteLogging) {\n                const batch = this.logQueue.splice(0, this.config.batchSize);\n                const promise = this.sendLogBatch(batch);\n                \n                if (synchronous) {\n                    await promise;\n                } else {\n                    promises.push(promise);\n                }\n            }\n            \n            // Send analytics\n            if (this.analyticsQueue.length > 0 && this.config.enableAnalytics) {\n                const batch = this.analyticsQueue.splice(0, this.config.batchSize);\n                const promise = this.sendAnalyticsBatch(batch);\n                \n                if (synchronous) {\n                    await promise;\n                } else {\n                    promises.push(promise);\n                }\n            }\n            \n            if (!synchronous && promises.length > 0) {\n                await Promise.allSettled(promises);\n            }\n            \n            this.metrics.lastReportTime = Date.now();\n            \n        } catch (error) {\n            console.error('Failed to send queued reports:', error);\n            this.metrics.reportingFailures++;\n        }\n    }\n    \n    /**\n     * Send error report\n     */\n    async sendErrorReport(report) {\n        return this.sendErrorBatch([report]);\n    }\n    \n    /**\n     * Send error batch\n     */\n    async sendErrorBatch(batch) {\n        if (batch.length === 0) return;\n        \n        try {\n            const response = await fetch(this.config.reportingEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Session-ID': this.sessionId\n                },\n                body: JSON.stringify({\n                    type: 'errors',\n                    batch,\n                    metadata: {\n                        timestamp: Date.now(),\n                        batchSize: batch.length\n                    }\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            \n            if (this.config.debugMode) {\n                console.log(`Sent ${batch.length} error reports`);\n            }\n            \n        } catch (error) {\n            console.error('Failed to send error batch:', error);\n            \n            // Re-queue for retry\n            this.errorQueue.unshift(...batch);\n            this.scheduleRetry('errors', batch);\n            \n            throw error;\n        }\n    }\n    \n    /**\n     * Send log batch\n     */\n    async sendLogBatch(batch) {\n        if (batch.length === 0) return;\n        \n        try {\n            const response = await fetch(this.config.reportingEndpoint + '/logs', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Session-ID': this.sessionId\n                },\n                body: JSON.stringify({\n                    type: 'logs',\n                    batch,\n                    metadata: {\n                        timestamp: Date.now(),\n                        batchSize: batch.length\n                    }\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            \n            if (this.config.debugMode) {\n                console.log(`Sent ${batch.length} log entries`);\n            }\n            \n        } catch (error) {\n            console.error('Failed to send log batch:', error);\n            \n            // Re-queue for retry\n            this.logQueue.unshift(...batch);\n            this.scheduleRetry('logs', batch);\n            \n            throw error;\n        }\n    }\n    \n    /**\n     * Send analytics batch\n     */\n    async sendAnalyticsBatch(batch) {\n        if (batch.length === 0) return;\n        \n        try {\n            const response = await fetch(this.config.analyticsEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Session-ID': this.sessionId\n                },\n                body: JSON.stringify({\n                    type: 'analytics',\n                    batch,\n                    metadata: {\n                        timestamp: Date.now(),\n                        batchSize: batch.length\n                    }\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            \n            if (this.config.debugMode) {\n                console.log(`Sent ${batch.length} analytics events`);\n            }\n            \n        } catch (error) {\n            console.error('Failed to send analytics batch:', error);\n            \n            // Re-queue for retry\n            this.analyticsQueue.unshift(...batch);\n            this.scheduleRetry('analytics', batch);\n            \n            throw error;\n        }\n    }\n    \n    /**\n     * Schedule retry\n     */\n    scheduleRetry(type, batch) {\n        const retryKey = `${type}_${Date.now()}`;\n        let attempts = 0;\n        \n        const retry = async () => {\n            attempts++;\n            \n            if (attempts > this.config.retryAttempts) {\n                console.error(`Max retry attempts reached for ${type}`);\n                return;\n            }\n            \n            try {\n                switch (type) {\n                    case 'errors':\n                        await this.sendErrorBatch(batch);\n                        break;\n                    case 'logs':\n                        await this.sendLogBatch(batch);\n                        break;\n                    case 'analytics':\n                        await this.sendAnalyticsBatch(batch);\n                        break;\n                }\n                \n                // Success - clear retry\n                this.retryTimeouts.delete(retryKey);\n                \n            } catch (error) {\n                // Schedule next retry\n                const timeout = setTimeout(retry, this.config.retryDelay * attempts);\n                this.retryTimeouts.set(retryKey, timeout);\n            }\n        };\n        \n        const timeout = setTimeout(retry, this.config.retryDelay);\n        this.retryTimeouts.set(retryKey, timeout);\n    }\n    \n    /**\n     * Generate session ID\n     */\n    generateSessionId() {\n        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    }\n    \n    /**\n     * Generate unique ID\n     */\n    generateId() {\n        return Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    }\n    \n    /**\n     * Get user ID\n     */\n    getUserId() {\n        // Try to get from localStorage\n        let userId = localStorage.getItem('user_id');\n        \n        if (!userId) {\n            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n            localStorage.setItem('user_id', userId);\n        }\n        \n        return userId;\n    }\n    \n    /**\n     * Get queue status\n     */\n    getQueueStatus() {\n        return {\n            errors: this.errorQueue.length,\n            logs: this.logQueue.length,\n            analytics: this.analyticsQueue.length,\n            retries: this.retryTimeouts.size\n        };\n    }\n    \n    /**\n     * Get metrics\n     */\n    getMetrics() {\n        return {\n            ...this.metrics,\n            queueStatus: this.getQueueStatus(),\n            sessionId: this.sessionId,\n            userId: this.userId\n        };\n    }\n    \n    /**\n     * Clear queues\n     */\n    clearQueues() {\n        this.errorQueue = [];\n        this.logQueue = [];\n        this.analyticsQueue = [];\n        \n        console.log('All queues cleared');\n    }\n    \n    /**\n     * Update configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        \n        // Restart interval if changed\n        if (newConfig.reportingInterval) {\n            this.startReportingInterval();\n        }\n        \n        console.log('Error reporting configuration updated:', this.config);\n    }\n    \n    /**\n     * Set user consent\n     */\n    setUserConsent(consent) {\n        this.config.userConsent = consent;\n        \n        if (!consent) {\n            // Clear analytics queue if consent withdrawn\n            this.analyticsQueue = [];\n        }\n        \n        console.log('User consent updated:', consent);\n    }\n    \n    /**\n     * Export logs\n     */\n    exportLogs(format = 'json') {\n        const data = {\n            session: {\n                id: this.sessionId,\n                userId: this.userId,\n                timestamp: Date.now()\n            },\n            errors: this.errorQueue,\n            logs: this.logQueue,\n            analytics: this.analyticsQueue,\n            metrics: this.metrics\n        };\n        \n        switch (format) {\n            case 'json':\n                return JSON.stringify(data, null, 2);\n            case 'csv':\n                return this.convertToCSV(data);\n            default:\n                return data;\n        }\n    }\n    \n    /**\n     * Convert to CSV format\n     */\n    convertToCSV(data) {\n        const csvRows = [];\n        \n        // Headers\n        csvRows.push('Type,Timestamp,Level,Message,Data');\n        \n        // Errors\n        data.errors.forEach(error => {\n            csvRows.push(`Error,${error.timestamp},${error.severity},\"${error.message}\",\"${JSON.stringify(error).replace(/\"/g, '\"\"')}\"`);\n        });\n        \n        // Logs\n        data.logs.forEach(log => {\n            csvRows.push(`Log,${log.timestamp},${log.level},\"${log.message}\",\"${JSON.stringify(log.data || {}).replace(/\"/g, '\"\"')}\"`);\n        });\n        \n        return csvRows.join('\\n');\n    }\n    \n    /**\n     * Cleanup and destroy\n     */\n    destroy() {\n        // Send final reports\n        this.sendQueuedReports(true);\n        \n        // Clear intervals\n        if (this.reportingInterval) {\n            clearInterval(this.reportingInterval);\n        }\n        \n        // Clear retry timeouts\n        this.retryTimeouts.forEach(timeout => clearTimeout(timeout));\n        this.retryTimeouts.clear();\n        \n        // Restore original console methods\n        if (this.originalConsole) {\n            Object.assign(console, this.originalConsole);\n        }\n        \n        // Clear queues\n        this.clearQueues();\n        \n        console.log('Error Reporting System destroyed');\n    }\n}\n\nexport default ErrorReportingSystem;"