/**\n * Comprehensive Error Handler\n * Handles all types of errors with graceful recovery, logging, and reporting\n */\nclass ComprehensiveErrorHandler {\n    constructor(gameEngine) {\n        this.gameEngine = gameEngine;\n        \n        // Error tracking\n        this.errorHistory = [];\n        this.errorCounts = new Map();\n        this.criticalErrors = [];\n        this.recoveryAttempts = new Map();\n        \n        // Configuration\n        this.config = {\n            maxErrorHistory: 1000,\n            maxRecoveryAttempts: 3,\n            criticalErrorThreshold: 5,\n            reportingEnabled: true,\n            autoSaveOnError: true,\n            fallbacksEnabled: true,\n            debugMode: process.env.NODE_ENV === 'development'\n        };\n        \n        // Error categories\n        this.errorCategories = {\n            SYSTEM: 'system',\n            RENDERING: 'rendering',\n            AUDIO: 'audio',\n            NETWORK: 'network',\n            STORAGE: 'storage',\n            INPUT: 'input',\n            PHYSICS: 'physics',\n            AI: 'ai',\n            UI: 'ui',\n            ASSET: 'asset'\n        };\n        \n        // Recovery strategies\n        this.recoveryStrategies = new Map();\n        this.fallbackSystems = new Map();\n        \n        // State preservation\n        this.gameStateBackup = null;\n        this.lastSafeState = null;\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialize error handler\n     */\n    initialize() {\n        this.setupGlobalErrorHandlers();\n        this.setupRecoveryStrategies();\n        this.setupFallbackSystems();\n        this.setupStatePreservation();\n        this.setupErrorReporting();\n        \n        console.log('Comprehensive Error Handler initialized');\n    }\n    \n    /**\n     * Setup global error handlers\n     */\n    setupGlobalErrorHandlers() {\n        // Unhandled JavaScript errors\n        window.addEventListener('error', (event) => {\n            this.handleError({\n                type: 'javascript',\n                category: this.errorCategories.SYSTEM,\n                message: event.message,\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno,\n                error: event.error,\n                stack: event.error?.stack,\n                severity: 'high',\n                timestamp: Date.now()\n            });\n        });\n        \n        // Unhandled promise rejections\n        window.addEventListener('unhandledrejection', (event) => {\n            this.handleError({\n                type: 'promise_rejection',\n                category: this.errorCategories.SYSTEM,\n                message: event.reason?.message || 'Unhandled promise rejection',\n                error: event.reason,\n                stack: event.reason?.stack,\n                severity: 'high',\n                timestamp: Date.now()\n            });\n        });\n        \n        // WebGL context lost\n        window.addEventListener('webglcontextlost', (event) => {\n            event.preventDefault();\n            this.handleError({\n                type: 'webgl_context_lost',\n                category: this.errorCategories.RENDERING,\n                message: 'WebGL context lost',\n                severity: 'critical',\n                timestamp: Date.now(),\n                recoverable: true\n            });\n        });\n        \n        // WebGL context restored\n        window.addEventListener('webglcontextrestored', (event) => {\n            this.handleRecovery({\n                type: 'webgl_context_restored',\n                category: this.errorCategories.RENDERING,\n                message: 'WebGL context restored',\n                timestamp: Date.now()\n            });\n        });\n        \n        // Memory warnings\n        if ('memory' in performance) {\n            setInterval(() => {\n                const memInfo = performance.memory;\n                const usedPercent = (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100;\n                \n                if (usedPercent > 90) {\n                    this.handleError({\n                        type: 'memory_warning',\n                        category: this.errorCategories.SYSTEM,\n                        message: `High memory usage: ${usedPercent.toFixed(1)}%`,\n                        severity: 'medium',\n                        timestamp: Date.now(),\n                        data: { memInfo }\n                    });\n                }\n            }, 30000); // Check every 30 seconds\n        }\n    }\n    \n    /**\n     * Setup recovery strategies for different error types\n     */\n    setupRecoveryStrategies() {\n        // Rendering errors\n        this.recoveryStrategies.set('webgl_context_lost', async (error) => {\n            console.log('Attempting WebGL context recovery...');\n            \n            // Wait for context restoration\n            await this.waitForWebGLRestore();\n            \n            // Reinitialize rendering system\n            if (this.gameEngine.renderer) {\n                await this.gameEngine.renderer.reinitialize();\n            }\n            \n            // Reload textures and shaders\n            if (this.gameEngine.assetManager) {\n                await this.gameEngine.assetManager.reloadRenderingAssets();\n            }\n            \n            return { success: true, message: 'WebGL context recovered' };\n        });\n        \n        // Audio errors\n        this.recoveryStrategies.set('audio_context_suspended', async (error) => {\n            console.log('Attempting audio context recovery...');\n            \n            if (this.gameEngine.audioManager) {\n                const result = await this.gameEngine.audioManager.resumeContext();\n                return { success: result, message: result ? 'Audio context resumed' : 'Audio recovery failed' };\n            }\n            \n            return { success: false, message: 'No audio manager available' };\n        });\n        \n        // Network errors\n        this.recoveryStrategies.set('network_error', async (error) => {\n            console.log('Attempting network recovery...');\n            \n            // Check connectivity\n            const isOnline = navigator.onLine;\n            if (!isOnline) {\n                return { success: false, message: 'Device is offline' };\n            }\n            \n            // Retry failed requests\n            if (error.data?.retryFunction) {\n                try {\n                    await error.data.retryFunction();\n                    return { success: true, message: 'Network request retried successfully' };\n                } catch (retryError) {\n                    return { success: false, message: 'Network retry failed' };\n                }\n            }\n            \n            return { success: false, message: 'No retry mechanism available' };\n        });\n        \n        // Storage errors\n        this.recoveryStrategies.set('storage_error', async (error) => {\n            console.log('Attempting storage recovery...');\n            \n            // Try alternative storage methods\n            const storageManager = this.gameEngine.storageManager;\n            if (storageManager) {\n                const recovered = await storageManager.switchToFallbackStorage();\n                return { success: recovered, message: recovered ? 'Switched to fallback storage' : 'Storage recovery failed' };\n            }\n            \n            return { success: false, message: 'No storage manager available' };\n        });\n        \n        // Memory errors\n        this.recoveryStrategies.set('memory_warning', async (error) => {\n            console.log('Attempting memory cleanup...');\n            \n            // Force garbage collection if available\n            if (window.gc) {\n                window.gc();\n            }\n            \n            // Clear caches\n            if (this.gameEngine.assetManager) {\n                this.gameEngine.assetManager.clearUnusedAssets();\n            }\n            \n            // Reduce quality settings\n            if (this.gameEngine.performanceManager) {\n                this.gameEngine.performanceManager.enableMemoryOptimization();\n            }\n            \n            return { success: true, message: 'Memory optimization applied' };\n        });\n    }\n    \n    /**\n     * Setup fallback systems\n     */\n    setupFallbackSystems() {\n        // Rendering fallback\n        this.fallbackSystems.set(this.errorCategories.RENDERING, {\n            name: 'Canvas 2D Fallback',\n            initialize: async () => {\n                console.log('Initializing Canvas 2D fallback renderer...');\n                \n                // Create 2D canvas fallback\n                const canvas = document.createElement('canvas');\n                const ctx = canvas.getContext('2d');\n                \n                if (!ctx) {\n                    throw new Error('Canvas 2D not available');\n                }\n                \n                // Setup basic 2D rendering\n                this.setupCanvas2DFallback(canvas, ctx);\n                \n                return { canvas, context: ctx };\n            },\n            active: false\n        });\n        \n        // Audio fallback\n        this.fallbackSystems.set(this.errorCategories.AUDIO, {\n            name: 'Silent Audio Fallback',\n            initialize: async () => {\n                console.log('Initializing silent audio fallback...');\n                \n                // Create mock audio system\n                const mockAudio = {\n                    play: () => Promise.resolve(),\n                    pause: () => {},\n                    stop: () => {},\n                    setVolume: () => {},\n                    isPlaying: () => false\n                };\n                \n                return mockAudio;\n            },\n            active: false\n        });\n        \n        // Network fallback\n        this.fallbackSystems.set(this.errorCategories.NETWORK, {\n            name: 'Offline Mode',\n            initialize: async () => {\n                console.log('Initializing offline mode...');\n                \n                // Enable offline features\n                if (this.gameEngine.offlineManager) {\n                    await this.gameEngine.offlineManager.enable();\n                }\n                \n                // Use cached data\n                return { offline: true };\n            },\n            active: false\n        });\n        \n        // Storage fallback\n        this.fallbackSystems.set(this.errorCategories.STORAGE, {\n            name: 'Memory Storage Fallback',\n            initialize: async () => {\n                console.log('Initializing memory storage fallback...');\n                \n                // Create in-memory storage\n                const memoryStorage = new Map();\n                \n                return {\n                    get: (key) => memoryStorage.get(key),\n                    set: (key, value) => memoryStorage.set(key, value),\n                    remove: (key) => memoryStorage.delete(key),\n                    clear: () => memoryStorage.clear()\n                };\n            },\n            active: false\n        });\n    }\n    \n    /**\n     * Setup state preservation system\n     */\n    setupStatePreservation() {\n        // Auto-save game state periodically\n        if (this.config.autoSaveOnError) {\n            setInterval(() => {\n                this.preserveGameState();\n            }, 30000); // Every 30 seconds\n        }\n        \n        // Save state before page unload\n        window.addEventListener('beforeunload', () => {\n            this.preserveGameState();\n        });\n    }\n    \n    /**\n     * Setup error reporting system\n     */\n    setupErrorReporting() {\n        if (!this.config.reportingEnabled) return;\n        \n        // Setup reporting endpoint\n        this.reportingEndpoint = '/api/errors';\n        \n        // Batch error reports\n        this.errorReportQueue = [];\n        this.reportingInterval = setInterval(() => {\n            this.sendErrorReports();\n        }, 60000); // Every minute\n    }\n    \n    /**\n     * Handle an error\n     */\n    async handleError(errorInfo) {\n        try {\n            // Add to error history\n            this.errorHistory.push(errorInfo);\n            \n            // Limit history size\n            if (this.errorHistory.length > this.config.maxErrorHistory) {\n                this.errorHistory.shift();\n            }\n            \n            // Update error counts\n            const errorKey = `${errorInfo.category}:${errorInfo.type}`;\n            const count = (this.errorCounts.get(errorKey) || 0) + 1;\n            this.errorCounts.set(errorKey, count);\n            \n            // Log error\n            this.logError(errorInfo);\n            \n            // Check if critical\n            if (this.isCriticalError(errorInfo, count)) {\n                this.criticalErrors.push(errorInfo);\n                await this.handleCriticalError(errorInfo);\n            }\n            \n            // Attempt recovery\n            if (errorInfo.recoverable !== false) {\n                await this.attemptRecovery(errorInfo);\n            }\n            \n            // Report error\n            if (this.config.reportingEnabled) {\n                this.queueErrorReport(errorInfo);\n            }\n            \n            // Notify game engine\n            if (this.gameEngine.onError) {\n                this.gameEngine.onError(errorInfo);\n            }\n            \n        } catch (handlerError) {\n            console.error('Error in error handler:', handlerError);\n            // Prevent infinite loops\n        }\n    }\n    \n    /**\n     * Handle critical errors\n     */\n    async handleCriticalError(errorInfo) {\n        console.error('Critical error detected:', errorInfo);\n        \n        // Preserve game state immediately\n        await this.preserveGameState();\n        \n        // Enable fallback systems\n        if (this.config.fallbacksEnabled) {\n            await this.enableFallbackSystem(errorInfo.category);\n        }\n        \n        // Show user notification\n        this.showCriticalErrorNotification(errorInfo);\n        \n        // Consider graceful shutdown if too many critical errors\n        if (this.criticalErrors.length >= this.config.criticalErrorThreshold) {\n            await this.initiateGracefulShutdown();\n        }\n    }\n    \n    /**\n     * Attempt error recovery\n     */\n    async attemptRecovery(errorInfo) {\n        const recoveryKey = errorInfo.type;\n        const strategy = this.recoveryStrategies.get(recoveryKey);\n        \n        if (!strategy) {\n            console.log(`No recovery strategy for error type: ${recoveryKey}`);\n            return false;\n        }\n        \n        // Check recovery attempt limit\n        const attempts = this.recoveryAttempts.get(recoveryKey) || 0;\n        if (attempts >= this.config.maxRecoveryAttempts) {\n            console.log(`Max recovery attempts reached for: ${recoveryKey}`);\n            return false;\n        }\n        \n        try {\n            console.log(`Attempting recovery for: ${recoveryKey} (attempt ${attempts + 1})`);\n            \n            const result = await strategy(errorInfo);\n            \n            if (result.success) {\n                console.log(`Recovery successful: ${result.message}`);\n                this.recoveryAttempts.delete(recoveryKey); // Reset on success\n                \n                // Log recovery\n                this.logRecovery({\n                    errorType: recoveryKey,\n                    success: true,\n                    message: result.message,\n                    timestamp: Date.now()\n                });\n                \n                return true;\n            } else {\n                console.log(`Recovery failed: ${result.message}`);\n                this.recoveryAttempts.set(recoveryKey, attempts + 1);\n                return false;\n            }\n            \n        } catch (recoveryError) {\n            console.error(`Recovery attempt failed:`, recoveryError);\n            this.recoveryAttempts.set(recoveryKey, attempts + 1);\n            return false;\n        }\n    }\n    \n    /**\n     * Enable fallback system\n     */\n    async enableFallbackSystem(category) {\n        const fallback = this.fallbackSystems.get(category);\n        \n        if (!fallback || fallback.active) {\n            return false;\n        }\n        \n        try {\n            console.log(`Enabling fallback system: ${fallback.name}`);\n            \n            const result = await fallback.initialize();\n            fallback.active = true;\n            fallback.instance = result;\n            \n            // Notify game engine\n            if (this.gameEngine.onFallbackEnabled) {\n                this.gameEngine.onFallbackEnabled(category, result);\n            }\n            \n            return true;\n            \n        } catch (fallbackError) {\n            console.error(`Fallback system initialization failed:`, fallbackError);\n            return false;\n        }\n    }\n    \n    /**\n     * Preserve game state\n     */\n    async preserveGameState() {\n        try {\n            if (!this.gameEngine.getGameState) {\n                return false;\n            }\n            \n            const gameState = this.gameEngine.getGameState();\n            \n            // Create backup\n            this.gameStateBackup = {\n                state: JSON.parse(JSON.stringify(gameState)),\n                timestamp: Date.now(),\n                version: this.gameEngine.version || '1.0.0'\n            };\n            \n            // Save to storage\n            if (this.gameEngine.storageManager) {\n                await this.gameEngine.storageManager.saveEmergencyBackup(this.gameStateBackup);\n            } else {\n                // Fallback to localStorage\n                localStorage.setItem('game_emergency_backup', JSON.stringify(this.gameStateBackup));\n            }\n            \n            this.lastSafeState = Date.now();\n            return true;\n            \n        } catch (error) {\n            console.error('Failed to preserve game state:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * Restore game state\n     */\n    async restoreGameState() {\n        try {\n            let backup = this.gameStateBackup;\n            \n            // Try to load from storage if not in memory\n            if (!backup) {\n                if (this.gameEngine.storageManager) {\n                    backup = await this.gameEngine.storageManager.loadEmergencyBackup();\n                } else {\n                    // Fallback to localStorage\n                    const stored = localStorage.getItem('game_emergency_backup');\n                    if (stored) {\n                        backup = JSON.parse(stored);\n                    }\n                }\n            }\n            \n            if (!backup) {\n                console.log('No backup state available');\n                return false;\n            }\n            \n            // Restore state\n            if (this.gameEngine.restoreGameState) {\n                await this.gameEngine.restoreGameState(backup.state);\n                console.log('Game state restored from backup');\n                return true;\n            }\n            \n            return false;\n            \n        } catch (error) {\n            console.error('Failed to restore game state:', error);\n            return false;\n        }\n    }"    \n 
   /**\n     * Wait for WebGL context restoration\n     */\n    waitForWebGLRestore() {\n        return new Promise((resolve) => {\n            const checkRestore = () => {\n                const canvas = document.querySelector('canvas');\n                if (canvas) {\n                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n                    if (gl && !gl.isContextLost()) {\n                        resolve();\n                        return;\n                    }\n                }\n                setTimeout(checkRestore, 100);\n            };\n            checkRestore();\n        });\n    }\n    \n    /**\n     * Setup Canvas 2D fallback renderer\n     */\n    setupCanvas2DFallback(canvas, ctx) {\n        // Basic 2D rendering setup\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        \n        // Create simple fallback renderer\n        const fallbackRenderer = {\n            clear: () => {\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n            },\n            drawRect: (x, y, width, height, color) => {\n                ctx.fillStyle = color;\n                ctx.fillRect(x, y, width, height);\n            },\n            drawText: (text, x, y, color, size) => {\n                ctx.fillStyle = color;\n                ctx.font = `${size}px Arial`;\n                ctx.fillText(text, x, y);\n            },\n            drawCircle: (x, y, radius, color) => {\n                ctx.beginPath();\n                ctx.arc(x, y, radius, 0, 2 * Math.PI);\n                ctx.fillStyle = color;\n                ctx.fill();\n            }\n        };\n        \n        // Replace main canvas\n        const mainCanvas = document.querySelector('#game-canvas');\n        if (mainCanvas && mainCanvas.parentNode) {\n            mainCanvas.parentNode.replaceChild(canvas, mainCanvas);\n        }\n        \n        return fallbackRenderer;\n    }\n    \n    /**\n     * Check if error is critical\n     */\n    isCriticalError(errorInfo, count) {\n        // Always critical\n        if (errorInfo.severity === 'critical') {\n            return true;\n        }\n        \n        // High severity with multiple occurrences\n        if (errorInfo.severity === 'high' && count >= 3) {\n            return true;\n        }\n        \n        // System errors\n        if (errorInfo.category === this.errorCategories.SYSTEM && count >= 2) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Log error\n     */\n    logError(errorInfo) {\n        const logLevel = this.getLogLevel(errorInfo.severity);\n        const message = `[${errorInfo.category.toUpperCase()}] ${errorInfo.message}`;\n        \n        if (this.config.debugMode) {\n            console.group(`🚨 Error: ${errorInfo.type}`);\n            console.log('Message:', errorInfo.message);\n            console.log('Category:', errorInfo.category);\n            console.log('Severity:', errorInfo.severity);\n            console.log('Timestamp:', new Date(errorInfo.timestamp).toISOString());\n            if (errorInfo.stack) {\n                console.log('Stack:', errorInfo.stack);\n            }\n            if (errorInfo.data) {\n                console.log('Data:', errorInfo.data);\n            }\n            console.groupEnd();\n        }\n        \n        // Log to appropriate level\n        switch (logLevel) {\n            case 'error':\n                console.error(message, errorInfo);\n                break;\n            case 'warn':\n                console.warn(message, errorInfo);\n                break;\n            default:\n                console.log(message, errorInfo);\n        }\n    }\n    \n    /**\n     * Log recovery attempt\n     */\n    logRecovery(recoveryInfo) {\n        if (this.config.debugMode) {\n            console.group(`🔧 Recovery: ${recoveryInfo.errorType}`);\n            console.log('Success:', recoveryInfo.success);\n            console.log('Message:', recoveryInfo.message);\n            console.log('Timestamp:', new Date(recoveryInfo.timestamp).toISOString());\n            console.groupEnd();\n        }\n        \n        const message = `Recovery ${recoveryInfo.success ? 'succeeded' : 'failed'} for ${recoveryInfo.errorType}: ${recoveryInfo.message}`;\n        console.log(message);\n    }\n    \n    /**\n     * Get log level for severity\n     */\n    getLogLevel(severity) {\n        switch (severity) {\n            case 'critical':\n            case 'high':\n                return 'error';\n            case 'medium':\n                return 'warn';\n            default:\n                return 'log';\n        }\n    }\n    \n    /**\n     * Queue error report\n     */\n    queueErrorReport(errorInfo) {\n        // Sanitize error info for reporting\n        const report = {\n            type: errorInfo.type,\n            category: errorInfo.category,\n            message: errorInfo.message,\n            severity: errorInfo.severity,\n            timestamp: errorInfo.timestamp,\n            userAgent: navigator.userAgent,\n            url: window.location.href,\n            gameVersion: this.gameEngine.version || 'unknown',\n            sessionId: this.getSessionId()\n        };\n        \n        // Add stack trace for critical errors\n        if (errorInfo.severity === 'critical' && errorInfo.stack) {\n            report.stack = errorInfo.stack;\n        }\n        \n        this.errorReportQueue.push(report);\n    }\n    \n    /**\n     * Send error reports\n     */\n    async sendErrorReports() {\n        if (this.errorReportQueue.length === 0) {\n            return;\n        }\n        \n        const reports = [...this.errorReportQueue];\n        this.errorReportQueue = [];\n        \n        try {\n            const response = await fetch(this.reportingEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ errors: reports })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Reporting failed: ${response.status}`);\n            }\n            \n            console.log(`Sent ${reports.length} error reports`);\n            \n        } catch (error) {\n            console.error('Failed to send error reports:', error);\n            // Re-queue reports for retry\n            this.errorReportQueue.unshift(...reports);\n        }\n    }\n    \n    /**\n     * Show critical error notification\n     */\n    showCriticalErrorNotification(errorInfo) {\n        // Create notification element\n        const notification = document.createElement('div');\n        notification.className = 'critical-error-notification';\n        notification.innerHTML = `\n            <div style=\"\n                position: fixed;\n                top: 20px;\n                right: 20px;\n                background: #ff4444;\n                color: white;\n                padding: 20px;\n                border-radius: 8px;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n                z-index: 10000;\n                max-width: 400px;\n                font-family: Arial, sans-serif;\n            \">\n                <div style=\"font-weight: bold; margin-bottom: 10px;\">\n                    ⚠️ Critical Error Detected\n                </div>\n                <div style=\"margin-bottom: 15px; font-size: 14px;\">\n                    ${errorInfo.message}\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <button id=\"error-retry\" style=\"\n                        background: white;\n                        color: #ff4444;\n                        border: none;\n                        padding: 8px 16px;\n                        border-radius: 4px;\n                        cursor: pointer;\n                        font-weight: bold;\n                    \">Retry</button>\n                    <button id=\"error-restore\" style=\"\n                        background: rgba(255,255,255,0.2);\n                        color: white;\n                        border: 1px solid white;\n                        padding: 8px 16px;\n                        border-radius: 4px;\n                        cursor: pointer;\n                    \">Restore</button>\n                    <button id=\"error-dismiss\" style=\"\n                        background: transparent;\n                        color: white;\n                        border: 1px solid white;\n                        padding: 8px 16px;\n                        border-radius: 4px;\n                        cursor: pointer;\n                    \">Dismiss</button>\n                </div>\n            </div>\n        `;\n        \n        document.body.appendChild(notification);\n        \n        // Setup button handlers\n        document.getElementById('error-retry').addEventListener('click', () => {\n            this.attemptRecovery(errorInfo);\n            notification.remove();\n        });\n        \n        document.getElementById('error-restore').addEventListener('click', async () => {\n            await this.restoreGameState();\n            notification.remove();\n        });\n        \n        document.getElementById('error-dismiss').addEventListener('click', () => {\n            notification.remove();\n        });\n        \n        // Auto-dismiss after 30 seconds\n        setTimeout(() => {\n            if (notification.parentNode) {\n                notification.remove();\n            }\n        }, 30000);\n    }\n    \n    /**\n     * Initiate graceful shutdown\n     */\n    async initiateGracefulShutdown() {\n        console.warn('Initiating graceful shutdown due to critical errors');\n        \n        try {\n            // Save final state\n            await this.preserveGameState();\n            \n            // Notify user\n            this.showShutdownNotification();\n            \n            // Stop game systems\n            if (this.gameEngine.shutdown) {\n                await this.gameEngine.shutdown();\n            }\n            \n            // Clear intervals\n            if (this.reportingInterval) {\n                clearInterval(this.reportingInterval);\n            }\n            \n        } catch (error) {\n            console.error('Error during graceful shutdown:', error);\n        }\n    }\n    \n    /**\n     * Show shutdown notification\n     */\n    showShutdownNotification() {\n        const notification = document.createElement('div');\n        notification.innerHTML = `\n            <div style=\"\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                background: rgba(0,0,0,0.9);\n                color: white;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                justify-content: center;\n                z-index: 10001;\n                font-family: Arial, sans-serif;\n                text-align: center;\n            \">\n                <div style=\"font-size: 48px; margin-bottom: 20px;\">⚠️</div>\n                <h2 style=\"margin-bottom: 20px;\">Game Temporarily Unavailable</h2>\n                <p style=\"margin-bottom: 30px; max-width: 500px; line-height: 1.5;\">\n                    The game has encountered multiple critical errors and needs to restart.\n                    Your progress has been saved automatically.\n                </p>\n                <button onclick=\"window.location.reload()\" style=\"\n                    background: #4CAF50;\n                    color: white;\n                    border: none;\n                    padding: 15px 30px;\n                    border-radius: 8px;\n                    font-size: 16px;\n                    cursor: pointer;\n                    font-weight: bold;\n                \">Restart Game</button>\n            </div>\n        `;\n        \n        document.body.appendChild(notification);\n    }\n    \n    /**\n     * Get session ID\n     */\n    getSessionId() {\n        if (!this.sessionId) {\n            this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n        }\n        return this.sessionId;\n    }\n    \n    /**\n     * Handle recovery event\n     */\n    handleRecovery(recoveryInfo) {\n        console.log('Recovery event:', recoveryInfo);\n        \n        // Log recovery\n        this.logRecovery({\n            errorType: recoveryInfo.type,\n            success: true,\n            message: recoveryInfo.message,\n            timestamp: recoveryInfo.timestamp\n        });\n        \n        // Notify game engine\n        if (this.gameEngine.onRecovery) {\n            this.gameEngine.onRecovery(recoveryInfo);\n        }\n    }\n    \n    /**\n     * Get error statistics\n     */\n    getErrorStatistics() {\n        const stats = {\n            totalErrors: this.errorHistory.length,\n            criticalErrors: this.criticalErrors.length,\n            errorsByCategory: {},\n            errorsByType: {},\n            recentErrors: this.errorHistory.slice(-10),\n            recoveryAttempts: Object.fromEntries(this.recoveryAttempts),\n            activeFallbacks: []\n        };\n        \n        // Count by category\n        this.errorHistory.forEach(error => {\n            stats.errorsByCategory[error.category] = (stats.errorsByCategory[error.category] || 0) + 1;\n            stats.errorsByType[error.type] = (stats.errorsByType[error.type] || 0) + 1;\n        });\n        \n        // Active fallbacks\n        this.fallbackSystems.forEach((fallback, category) => {\n            if (fallback.active) {\n                stats.activeFallbacks.push({ category, name: fallback.name });\n            }\n        });\n        \n        return stats;\n    }\n    \n    /**\n     * Clear error history\n     */\n    clearErrorHistory() {\n        this.errorHistory = [];\n        this.errorCounts.clear();\n        this.criticalErrors = [];\n        this.recoveryAttempts.clear();\n        console.log('Error history cleared');\n    }\n    \n    /**\n     * Update configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        console.log('Error handler configuration updated:', this.config);\n    }\n    \n    /**\n     * Manually trigger error (for testing)\n     */\n    triggerTestError(type = 'test', category = 'system', severity = 'medium') {\n        this.handleError({\n            type,\n            category,\n            message: `Test error: ${type}`,\n            severity,\n            timestamp: Date.now(),\n            test: true\n        });\n    }\n    \n    /**\n     * Cleanup\n     */\n    destroy() {\n        // Clear intervals\n        if (this.reportingInterval) {\n            clearInterval(this.reportingInterval);\n        }\n        \n        // Remove event listeners\n        window.removeEventListener('error', this.handleError);\n        window.removeEventListener('unhandledrejection', this.handleError);\n        \n        // Clear data\n        this.errorHistory = [];\n        this.errorCounts.clear();\n        this.criticalErrors = [];\n        this.recoveryAttempts.clear();\n        \n        console.log('Comprehensive Error Handler destroyed');\n    }\n}\n\nexport default ComprehensiveErrorHandler;"