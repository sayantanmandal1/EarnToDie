/**\n * Automatic Save State Preservation Manager\n * Handles automatic saving and recovery of game state during crashes\n */\nclass AutoSaveManager {\n    constructor(gameEngine, errorHandler) {\n        this.gameEngine = gameEngine;\n        this.errorHandler = errorHandler;\n        \n        // Configuration\n        this.config = {\n            autoSaveInterval: 30000, // 30 seconds\n            maxBackups: 10,\n            compressionEnabled: true,\n            encryptionEnabled: false,\n            storageQuotaLimit: 50 * 1024 * 1024, // 50MB\n            debugMode: process.env.NODE_ENV === 'development'\n        };\n        \n        // State tracking\n        this.saveHistory = [];\n        this.lastSaveTime = 0;\n        this.saveInProgress = false;\n        this.autoSaveInterval = null;\n        \n        // Storage systems\n        this.storageProviders = {\n            indexedDB: null,\n            localStorage: null,\n            sessionStorage: null,\n            memory: new Map()\n        };\n        \n        // Compression and encryption\n        this.compressionWorker = null;\n        this.encryptionKey = null;\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialize auto-save manager\n     */\n    async initialize() {\n        console.log('Initializing Auto-Save Manager...');\n        \n        await this.initializeStorageProviders();\n        this.setupCompressionWorker();\n        this.setupEncryption();\n        this.startAutoSave();\n        this.setupEventListeners();\n        \n        // Attempt to recover from previous session\n        await this.attemptRecovery();\n        \n        console.log('Auto-Save Manager initialized');\n    }\n    \n    /**\n     * Initialize storage providers\n     */\n    async initializeStorageProviders() {\n        // IndexedDB (primary)\n        try {\n            this.storageProviders.indexedDB = await this.initializeIndexedDB();\n            console.log('IndexedDB storage initialized');\n        } catch (error) {\n            console.warn('IndexedDB initialization failed:', error);\n        }\n        \n        // LocalStorage (fallback)\n        try {\n            if (typeof Storage !== 'undefined' && localStorage) {\n                this.storageProviders.localStorage = {\n                    get: (key) => {\n                        const item = localStorage.getItem(key);\n                        return item ? JSON.parse(item) : null;\n                    },\n                    set: (key, value) => {\n                        localStorage.setItem(key, JSON.stringify(value));\n                    },\n                    remove: (key) => {\n                        localStorage.removeItem(key);\n                    },\n                    clear: () => {\n                        localStorage.clear();\n                    }\n                };\n                console.log('LocalStorage storage initialized');\n            }\n        } catch (error) {\n            console.warn('LocalStorage initialization failed:', error);\n        }\n        \n        // SessionStorage (temporary)\n        try {\n            if (typeof Storage !== 'undefined' && sessionStorage) {\n                this.storageProviders.sessionStorage = {\n                    get: (key) => {\n                        const item = sessionStorage.getItem(key);\n                        return item ? JSON.parse(item) : null;\n                    },\n                    set: (key, value) => {\n                        sessionStorage.setItem(key, JSON.stringify(value));\n                    },\n                    remove: (key) => {\n                        sessionStorage.removeItem(key);\n                    },\n                    clear: () => {\n                        sessionStorage.clear();\n                    }\n                };\n                console.log('SessionStorage storage initialized');\n            }\n        } catch (error) {\n            console.warn('SessionStorage initialization failed:', error);\n        }\n    }\n    \n    /**\n     * Initialize IndexedDB\n     */\n    initializeIndexedDB() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open('GameAutoSave', 1);\n            \n            request.onerror = () => reject(request.error);\n            \n            request.onsuccess = () => {\n                const db = request.result;\n                \n                resolve({\n                    get: (key) => {\n                        return new Promise((resolve, reject) => {\n                            const transaction = db.transaction(['saves'], 'readonly');\n                            const store = transaction.objectStore('saves');\n                            const request = store.get(key);\n                            \n                            request.onsuccess = () => resolve(request.result?.data || null);\n                            request.onerror = () => reject(request.error);\n                        });\n                    },\n                    set: (key, value) => {\n                        return new Promise((resolve, reject) => {\n                            const transaction = db.transaction(['saves'], 'readwrite');\n                            const store = transaction.objectStore('saves');\n                            const request = store.put({ id: key, data: value, timestamp: Date.now() });\n                            \n                            request.onsuccess = () => resolve();\n                            request.onerror = () => reject(request.error);\n                        });\n                    },\n                    remove: (key) => {\n                        return new Promise((resolve, reject) => {\n                            const transaction = db.transaction(['saves'], 'readwrite');\n                            const store = transaction.objectStore('saves');\n                            const request = store.delete(key);\n                            \n                            request.onsuccess = () => resolve();\n                            request.onerror = () => reject(request.error);\n                        });\n                    },\n                    clear: () => {\n                        return new Promise((resolve, reject) => {\n                            const transaction = db.transaction(['saves'], 'readwrite');\n                            const store = transaction.objectStore('saves');\n                            const request = store.clear();\n                            \n                            request.onsuccess = () => resolve();\n                            request.onerror = () => reject(request.error);\n                        });\n                    },\n                    getAllKeys: () => {\n                        return new Promise((resolve, reject) => {\n                            const transaction = db.transaction(['saves'], 'readonly');\n                            const store = transaction.objectStore('saves');\n                            const request = store.getAllKeys();\n                            \n                            request.onsuccess = () => resolve(request.result);\n                            request.onerror = () => reject(request.error);\n                        });\n                    }\n                });\n            };\n            \n            request.onupgradeneeded = () => {\n                const db = request.result;\n                \n                if (!db.objectStoreNames.contains('saves')) {\n                    const store = db.createObjectStore('saves', { keyPath: 'id' });\n                    store.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n            };\n        });\n    }\n    \n    /**\n     * Setup compression worker\n     */\n    setupCompressionWorker() {\n        if (!this.config.compressionEnabled) return;\n        \n        try {\n            // Create compression worker\n            const workerCode = `\n                self.onmessage = function(e) {\n                    const { action, data, id } = e.data;\n                    \n                    if (action === 'compress') {\n                        try {\n                            const compressed = JSON.stringify(data);\n                            // Simple compression simulation (in real implementation, use actual compression)\n                            const result = btoa(compressed);\n                            self.postMessage({ id, result, success: true });\n                        } catch (error) {\n                            self.postMessage({ id, error: error.message, success: false });\n                        }\n                    } else if (action === 'decompress') {\n                        try {\n                            const decompressed = atob(data);\n                            const result = JSON.parse(decompressed);\n                            self.postMessage({ id, result, success: true });\n                        } catch (error) {\n                            self.postMessage({ id, error: error.message, success: false });\n                        }\n                    }\n                };\n            `;\n            \n            const blob = new Blob([workerCode], { type: 'application/javascript' });\n            this.compressionWorker = new Worker(URL.createObjectURL(blob));\n            \n            console.log('Compression worker initialized');\n        } catch (error) {\n            console.warn('Compression worker initialization failed:', error);\n        }\n    }\n    \n    /**\n     * Setup encryption\n     */\n    setupEncryption() {\n        if (!this.config.encryptionEnabled) return;\n        \n        try {\n            // Generate encryption key (in real implementation, use proper key derivation)\n            this.encryptionKey = 'game_save_key_' + Date.now();\n            console.log('Encryption initialized');\n        } catch (error) {\n            console.warn('Encryption initialization failed:', error);\n        }\n    }\n    \n    /**\n     * Start automatic saving\n     */\n    startAutoSave() {\n        if (this.autoSaveInterval) {\n            clearInterval(this.autoSaveInterval);\n        }\n        \n        this.autoSaveInterval = setInterval(() => {\n            this.performAutoSave();\n        }, this.config.autoSaveInterval);\n        \n        console.log(`Auto-save started with ${this.config.autoSaveInterval}ms interval`);\n    }\n    \n    /**\n     * Setup event listeners\n     */\n    setupEventListeners() {\n        // Save before page unload\n        window.addEventListener('beforeunload', (e) => {\n            this.performEmergencySave();\n        });\n        \n        // Save on visibility change (mobile background)\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.performEmergencySave();\n            }\n        });\n        \n        // Save on errors\n        if (this.errorHandler) {\n            this.errorHandler.addEventListener?.('error', () => {\n                this.performEmergencySave();\n            });\n        }\n        \n        // Save on game state changes\n        if (this.gameEngine.addEventListener) {\n            this.gameEngine.addEventListener('statechange', () => {\n                this.scheduleAutoSave();\n            });\n        }\n    }\n    \n    /**\n     * Perform automatic save\n     */\n    async performAutoSave() {\n        if (this.saveInProgress) {\n            console.log('Auto-save skipped: save in progress');\n            return;\n        }\n        \n        try {\n            await this.saveGameState('autosave');\n        } catch (error) {\n            console.error('Auto-save failed:', error);\n        }\n    }\n    \n    /**\n     * Perform emergency save (synchronous)\n     */\n    performEmergencySave() {\n        try {\n            const gameState = this.getGameState();\n            if (!gameState) return;\n            \n            const saveData = {\n                state: gameState,\n                timestamp: Date.now(),\n                type: 'emergency',\n                version: this.gameEngine.version || '1.0.0'\n            };\n            \n            // Use synchronous localStorage for emergency saves\n            localStorage.setItem('game_emergency_save', JSON.stringify(saveData));\n            console.log('Emergency save completed');\n            \n        } catch (error) {\n            console.error('Emergency save failed:', error);\n        }\n    }\n    \n    /**\n     * Save game state\n     */\n    async saveGameState(type = 'manual') {\n        if (this.saveInProgress) {\n            throw new Error('Save already in progress');\n        }\n        \n        this.saveInProgress = true;\n        \n        try {\n            const gameState = this.getGameState();\n            if (!gameState) {\n                throw new Error('No game state available');\n            }\n            \n            const saveData = {\n                state: gameState,\n                timestamp: Date.now(),\n                type,\n                version: this.gameEngine.version || '1.0.0',\n                checksum: this.calculateChecksum(gameState)\n            };\n            \n            // Compress if enabled\n            if (this.config.compressionEnabled && this.compressionWorker) {\n                saveData.compressed = await this.compressData(saveData.state);\n                delete saveData.state; // Remove uncompressed data\n            }\n            \n            // Encrypt if enabled\n            if (this.config.encryptionEnabled) {\n                saveData.encrypted = await this.encryptData(saveData.compressed || saveData.state);\n                delete saveData.compressed;\n                delete saveData.state;\n            }\n            \n            // Save to storage\n            const saveKey = `save_${type}_${Date.now()}`;\n            await this.saveToStorage(saveKey, saveData);\n            \n            // Update history\n            this.saveHistory.push({\n                key: saveKey,\n                timestamp: saveData.timestamp,\n                type,\n                size: JSON.stringify(saveData).length\n            });\n            \n            // Cleanup old saves\n            await this.cleanupOldSaves();\n            \n            this.lastSaveTime = Date.now();\n            \n            if (this.config.debugMode) {\n                console.log(`Game state saved: ${saveKey}`);\n            }\n            \n            return saveKey;\n            \n        } finally {\n            this.saveInProgress = false;\n        }\n    }\n    \n    /**\n     * Load game state\n     */\n    async loadGameState(saveKey) {\n        try {\n            const saveData = await this.loadFromStorage(saveKey);\n            if (!saveData) {\n                throw new Error('Save data not found');\n            }\n            \n            let gameState;\n            \n            // Decrypt if needed\n            if (saveData.encrypted) {\n                const decrypted = await this.decryptData(saveData.encrypted);\n                gameState = decrypted;\n            } else if (saveData.compressed) {\n                // Decompress if needed\n                gameState = await this.decompressData(saveData.compressed);\n            } else {\n                gameState = saveData.state;\n            }\n            \n            // Verify checksum\n            if (saveData.checksum) {\n                const calculatedChecksum = this.calculateChecksum(gameState);\n                if (calculatedChecksum !== saveData.checksum) {\n                    throw new Error('Save data corrupted: checksum mismatch');\n                }\n            }\n            \n            return {\n                state: gameState,\n                metadata: {\n                    timestamp: saveData.timestamp,\n                    type: saveData.type,\n                    version: saveData.version\n                }\n            };\n            \n        } catch (error) {\n            console.error('Failed to load game state:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Attempt recovery from previous session\n     */\n    async attemptRecovery() {\n        try {\n            // Check for emergency save first\n            const emergencySave = localStorage.getItem('game_emergency_save');\n            if (emergencySave) {\n                const saveData = JSON.parse(emergencySave);\n                \n                if (this.shouldOfferRecovery(saveData)) {\n                    const recovered = await this.offerRecoveryToUser(saveData);\n                    if (recovered) {\n                        localStorage.removeItem('game_emergency_save');\n                        return true;\n                    }\n                }\n            }\n            \n            // Check for recent auto-saves\n            const recentSaves = await this.getRecentSaves();\n            if (recentSaves.length > 0) {\n                const latestSave = recentSaves[0];\n                const saveData = await this.loadGameState(latestSave.key);\n                \n                if (this.shouldOfferRecovery(saveData.metadata)) {\n                    return await this.offerRecoveryToUser(saveData);\n                }\n            }\n            \n            return false;\n            \n        } catch (error) {\n            console.error('Recovery attempt failed:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * Check if recovery should be offered\n     */\n    shouldOfferRecovery(saveData) {\n        const now = Date.now();\n        const saveAge = now - saveData.timestamp;\n        const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n        \n        // Offer recovery if save is recent and game wasn't properly closed\n        return saveAge < maxAge && (saveData.type === 'emergency' || saveData.type === 'autosave');\n    }\n    \n    /**\n     * Offer recovery to user\n     */\n    async offerRecoveryToUser(saveData) {\n        return new Promise((resolve) => {\n            const modal = document.createElement('div');\n            modal.innerHTML = `\n                <div style=\"\n                    position: fixed;\n                    top: 0;\n                    left: 0;\n                    right: 0;\n                    bottom: 0;\n                    background: rgba(0,0,0,0.8);\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    z-index: 10000;\n                    font-family: Arial, sans-serif;\n                \">\n                    <div style=\"\n                        background: white;\n                        padding: 30px;\n                        border-radius: 10px;\n                        max-width: 500px;\n                        text-align: center;\n                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n                    \">\n                        <h2 style=\"margin-bottom: 20px; color: #333;\">ðŸ”„ Recovery Available</h2>\n                        <p style=\"margin-bottom: 20px; color: #666; line-height: 1.5;\">\n                            We found a recent save from ${new Date(saveData.timestamp || saveData.metadata?.timestamp).toLocaleString()}.\n                            Would you like to restore your progress?\n                        </p>\n                        <div style=\"display: flex; gap: 15px; justify-content: center;\">\n                            <button id=\"recover-yes\" style=\"\n                                background: #4CAF50;\n                                color: white;\n                                border: none;\n                                padding: 12px 24px;\n                                border-radius: 6px;\n                                cursor: pointer;\n                                font-size: 16px;\n                                font-weight: bold;\n                            \">Restore Progress</button>\n                            <button id=\"recover-no\" style=\"\n                                background: #f44336;\n                                color: white;\n                                border: none;\n                                padding: 12px 24px;\n                                border-radius: 6px;\n                                cursor: pointer;\n                                font-size: 16px;\n                            \">Start Fresh</button>\n                        </div>\n                    </div>\n                </div>\n            `;\n            \n            document.body.appendChild(modal);\n            \n            document.getElementById('recover-yes').addEventListener('click', async () => {\n                try {\n                    const state = saveData.state || saveData.metadata;\n                    if (this.gameEngine.restoreGameState) {\n                        await this.gameEngine.restoreGameState(state);\n                    }\n                    modal.remove();\n                    resolve(true);\n                } catch (error) {\n                    console.error('Recovery failed:', error);\n                    modal.remove();\n                    resolve(false);\n                }\n            });\n            \n            document.getElementById('recover-no').addEventListener('click', () => {\n                modal.remove();\n                resolve(false);\n            });\n        });\n    }"    
\n    /**\n     * Get game state from engine\n     */\n    getGameState() {\n        try {\n            if (this.gameEngine.getGameState) {\n                return this.gameEngine.getGameState();\n            } else if (this.gameEngine.state) {\n                return this.gameEngine.state;\n            } else {\n                console.warn('No game state available from engine');\n                return null;\n            }\n        } catch (error) {\n            console.error('Failed to get game state:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Save to storage with fallback\n     */\n    async saveToStorage(key, data) {\n        const providers = ['indexedDB', 'localStorage', 'sessionStorage', 'memory'];\n        \n        for (const providerName of providers) {\n            const provider = this.storageProviders[providerName];\n            if (!provider) continue;\n            \n            try {\n                await provider.set(key, data);\n                if (this.config.debugMode) {\n                    console.log(`Saved to ${providerName}: ${key}`);\n                }\n                return providerName;\n            } catch (error) {\n                console.warn(`Failed to save to ${providerName}:`, error);\n                continue;\n            }\n        }\n        \n        throw new Error('All storage providers failed');\n    }\n    \n    /**\n     * Load from storage with fallback\n     */\n    async loadFromStorage(key) {\n        const providers = ['indexedDB', 'localStorage', 'sessionStorage', 'memory'];\n        \n        for (const providerName of providers) {\n            const provider = this.storageProviders[providerName];\n            if (!provider) continue;\n            \n            try {\n                const data = await provider.get(key);\n                if (data) {\n                    if (this.config.debugMode) {\n                        console.log(`Loaded from ${providerName}: ${key}`);\n                    }\n                    return data;\n                }\n            } catch (error) {\n                console.warn(`Failed to load from ${providerName}:`, error);\n                continue;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Compress data\n     */\n    compressData(data) {\n        return new Promise((resolve, reject) => {\n            if (!this.compressionWorker) {\n                resolve(data);\n                return;\n            }\n            \n            const id = Date.now() + Math.random();\n            \n            const handleMessage = (e) => {\n                if (e.data.id === id) {\n                    this.compressionWorker.removeEventListener('message', handleMessage);\n                    \n                    if (e.data.success) {\n                        resolve(e.data.result);\n                    } else {\n                        reject(new Error(e.data.error));\n                    }\n                }\n            };\n            \n            this.compressionWorker.addEventListener('message', handleMessage);\n            this.compressionWorker.postMessage({ action: 'compress', data, id });\n        });\n    }\n    \n    /**\n     * Decompress data\n     */\n    decompressData(data) {\n        return new Promise((resolve, reject) => {\n            if (!this.compressionWorker) {\n                resolve(data);\n                return;\n            }\n            \n            const id = Date.now() + Math.random();\n            \n            const handleMessage = (e) => {\n                if (e.data.id === id) {\n                    this.compressionWorker.removeEventListener('message', handleMessage);\n                    \n                    if (e.data.success) {\n                        resolve(e.data.result);\n                    } else {\n                        reject(new Error(e.data.error));\n                    }\n                }\n            };\n            \n            this.compressionWorker.addEventListener('message', handleMessage);\n            this.compressionWorker.postMessage({ action: 'decompress', data, id });\n        });\n    }\n    \n    /**\n     * Encrypt data (simple implementation)\n     */\n    async encryptData(data) {\n        if (!this.config.encryptionEnabled || !this.encryptionKey) {\n            return data;\n        }\n        \n        try {\n            // Simple XOR encryption (in production, use proper encryption)\n            const dataStr = JSON.stringify(data);\n            let encrypted = '';\n            \n            for (let i = 0; i < dataStr.length; i++) {\n                const keyChar = this.encryptionKey.charCodeAt(i % this.encryptionKey.length);\n                const dataChar = dataStr.charCodeAt(i);\n                encrypted += String.fromCharCode(dataChar ^ keyChar);\n            }\n            \n            return btoa(encrypted);\n        } catch (error) {\n            console.error('Encryption failed:', error);\n            return data;\n        }\n    }\n    \n    /**\n     * Decrypt data (simple implementation)\n     */\n    async decryptData(encryptedData) {\n        if (!this.config.encryptionEnabled || !this.encryptionKey) {\n            return encryptedData;\n        }\n        \n        try {\n            const encrypted = atob(encryptedData);\n            let decrypted = '';\n            \n            for (let i = 0; i < encrypted.length; i++) {\n                const keyChar = this.encryptionKey.charCodeAt(i % this.encryptionKey.length);\n                const encryptedChar = encrypted.charCodeAt(i);\n                decrypted += String.fromCharCode(encryptedChar ^ keyChar);\n            }\n            \n            return JSON.parse(decrypted);\n        } catch (error) {\n            console.error('Decryption failed:', error);\n            return encryptedData;\n        }\n    }\n    \n    /**\n     * Calculate checksum\n     */\n    calculateChecksum(data) {\n        const str = JSON.stringify(data);\n        let hash = 0;\n        \n        for (let i = 0; i < str.length; i++) {\n            const char = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n        \n        return hash.toString(36);\n    }\n    \n    /**\n     * Get recent saves\n     */\n    async getRecentSaves(limit = 10) {\n        try {\n            // Sort by timestamp descending\n            const recentSaves = this.saveHistory\n                .sort((a, b) => b.timestamp - a.timestamp)\n                .slice(0, limit);\n            \n            return recentSaves;\n        } catch (error) {\n            console.error('Failed to get recent saves:', error);\n            return [];\n        }\n    }\n    \n    /**\n     * Cleanup old saves\n     */\n    async cleanupOldSaves() {\n        try {\n            // Keep only the most recent saves\n            const sortedHistory = this.saveHistory.sort((a, b) => b.timestamp - a.timestamp);\n            const toDelete = sortedHistory.slice(this.config.maxBackups);\n            \n            for (const save of toDelete) {\n                await this.deleteSave(save.key);\n            }\n            \n            // Update history\n            this.saveHistory = sortedHistory.slice(0, this.config.maxBackups);\n            \n            if (this.config.debugMode && toDelete.length > 0) {\n                console.log(`Cleaned up ${toDelete.length} old saves`);\n            }\n        } catch (error) {\n            console.error('Cleanup failed:', error);\n        }\n    }\n    \n    /**\n     * Delete save\n     */\n    async deleteSave(key) {\n        const providers = ['indexedDB', 'localStorage', 'sessionStorage', 'memory'];\n        \n        for (const providerName of providers) {\n            const provider = this.storageProviders[providerName];\n            if (!provider) continue;\n            \n            try {\n                await provider.remove(key);\n            } catch (error) {\n                console.warn(`Failed to delete from ${providerName}:`, error);\n            }\n        }\n    }\n    \n    /**\n     * Schedule auto-save (debounced)\n     */\n    scheduleAutoSave() {\n        if (this.scheduleTimeout) {\n            clearTimeout(this.scheduleTimeout);\n        }\n        \n        this.scheduleTimeout = setTimeout(() => {\n            this.performAutoSave();\n        }, 5000); // 5 second delay\n    }\n    \n    /**\n     * Get storage usage\n     */\n    async getStorageUsage() {\n        const usage = {\n            total: 0,\n            byProvider: {},\n            saves: this.saveHistory.length\n        };\n        \n        try {\n            // Calculate total size from save history\n            usage.total = this.saveHistory.reduce((total, save) => total + (save.size || 0), 0);\n            \n            // Check quota if available\n            if ('storage' in navigator && 'estimate' in navigator.storage) {\n                const estimate = await navigator.storage.estimate();\n                usage.quota = estimate.quota;\n                usage.used = estimate.usage;\n                usage.available = estimate.quota - estimate.usage;\n            }\n            \n        } catch (error) {\n            console.error('Failed to get storage usage:', error);\n        }\n        \n        return usage;\n    }\n    \n    /**\n     * Export saves\n     */\n    async exportSaves() {\n        try {\n            const saves = [];\n            \n            for (const save of this.saveHistory) {\n                const data = await this.loadGameState(save.key);\n                if (data) {\n                    saves.push({\n                        key: save.key,\n                        timestamp: save.timestamp,\n                        type: save.type,\n                        state: data.state,\n                        metadata: data.metadata\n                    });\n                }\n            }\n            \n            const exportData = {\n                version: '1.0.0',\n                exportTime: Date.now(),\n                saves\n            };\n            \n            return JSON.stringify(exportData, null, 2);\n        } catch (error) {\n            console.error('Export failed:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Import saves\n     */\n    async importSaves(importData) {\n        try {\n            const data = JSON.parse(importData);\n            \n            if (!data.saves || !Array.isArray(data.saves)) {\n                throw new Error('Invalid import data format');\n            }\n            \n            let imported = 0;\n            \n            for (const save of data.saves) {\n                try {\n                    const saveKey = `imported_${save.key}_${Date.now()}`;\n                    await this.saveToStorage(saveKey, {\n                        state: save.state,\n                        timestamp: save.timestamp,\n                        type: 'imported',\n                        version: save.metadata?.version || '1.0.0',\n                        checksum: this.calculateChecksum(save.state)\n                    });\n                    \n                    this.saveHistory.push({\n                        key: saveKey,\n                        timestamp: save.timestamp,\n                        type: 'imported',\n                        size: JSON.stringify(save.state).length\n                    });\n                    \n                    imported++;\n                } catch (error) {\n                    console.error(`Failed to import save ${save.key}:`, error);\n                }\n            }\n            \n            console.log(`Imported ${imported} saves`);\n            return imported;\n        } catch (error) {\n            console.error('Import failed:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Clear all saves\n     */\n    async clearAllSaves() {\n        try {\n            for (const save of this.saveHistory) {\n                await this.deleteSave(save.key);\n            }\n            \n            this.saveHistory = [];\n            \n            // Clear emergency save\n            localStorage.removeItem('game_emergency_save');\n            \n            console.log('All saves cleared');\n        } catch (error) {\n            console.error('Failed to clear saves:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Get save statistics\n     */\n    getSaveStatistics() {\n        const stats = {\n            totalSaves: this.saveHistory.length,\n            lastSaveTime: this.lastSaveTime,\n            saveTypes: {},\n            totalSize: 0,\n            averageSize: 0,\n            oldestSave: null,\n            newestSave: null\n        };\n        \n        if (this.saveHistory.length > 0) {\n            // Count by type\n            this.saveHistory.forEach(save => {\n                stats.saveTypes[save.type] = (stats.saveTypes[save.type] || 0) + 1;\n                stats.totalSize += save.size || 0;\n            });\n            \n            stats.averageSize = stats.totalSize / this.saveHistory.length;\n            \n            // Find oldest and newest\n            const sorted = [...this.saveHistory].sort((a, b) => a.timestamp - b.timestamp);\n            stats.oldestSave = sorted[0];\n            stats.newestSave = sorted[sorted.length - 1];\n        }\n        \n        return stats;\n    }\n    \n    /**\n     * Update configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        \n        // Restart auto-save if interval changed\n        if (newConfig.autoSaveInterval) {\n            this.startAutoSave();\n        }\n        \n        console.log('Auto-save configuration updated:', this.config);\n    }\n    \n    /**\n     * Stop auto-save\n     */\n    stopAutoSave() {\n        if (this.autoSaveInterval) {\n            clearInterval(this.autoSaveInterval);\n            this.autoSaveInterval = null;\n            console.log('Auto-save stopped');\n        }\n    }\n    \n    /**\n     * Cleanup and destroy\n     */\n    destroy() {\n        // Stop auto-save\n        this.stopAutoSave();\n        \n        // Clear scheduled saves\n        if (this.scheduleTimeout) {\n            clearTimeout(this.scheduleTimeout);\n        }\n        \n        // Terminate compression worker\n        if (this.compressionWorker) {\n            this.compressionWorker.terminate();\n        }\n        \n        // Remove event listeners\n        window.removeEventListener('beforeunload', this.performEmergencySave);\n        document.removeEventListener('visibilitychange', this.performEmergencySave);\n        \n        // Clear data\n        this.saveHistory = [];\n        this.storageProviders = {};\n        \n        console.log('Auto-Save Manager destroyed');\n    }\n}\n\nexport default AutoSaveManager;"