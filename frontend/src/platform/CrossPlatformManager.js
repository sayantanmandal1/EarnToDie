/**\n * Cross-Platform Compatibility Manager\n * Handles mobile optimization, platform-specific profiles, touch controls, and PWA features\n */\nclass CrossPlatformManager {\n    constructor(gameEngine) {\n        this.gameEngine = gameEngine;\n        \n        // Platform detection\n        this.platform = {\n            type: 'desktop', // 'desktop', 'mobile', 'tablet'\n            os: 'unknown', // 'windows', 'macos', 'linux', 'ios', 'android'\n            browser: 'unknown', // 'chrome', 'firefox', 'safari', 'edge'\n            capabilities: {\n                touch: false,\n                webgl2: false,\n                webgpu: false,\n                serviceWorker: false,\n                webAssembly: false,\n                gamepad: false,\n                fullscreen: false,\n                pointerLock: false\n            },\n            performance: {\n                tier: 'medium', // 'low', 'medium', 'high'\n                memory: 4, // GB\n                cores: 4,\n                gpu: 'unknown'\n            },\n            screen: {\n                width: window.innerWidth,\n                height: window.innerHeight,\n                pixelRatio: window.devicePixelRatio || 1,\n                orientation: 'landscape'\n            }\n        };\n        \n        // Platform-specific configurations\n        this.platformConfigs = {\n            mobile: {\n                performance: {\n                    targetFPS: 30,\n                    maxTextureSize: 1024,\n                    shadowQuality: 'low',\n                    particleCount: 0.3,\n                    lodBias: 2.0\n                },\n                ui: {\n                    touchControls: true,\n                    virtualJoystick: true,\n                    largerButtons: true,\n                    simplifiedHUD: true\n                },\n                features: {\n                    autoSave: true,\n                    backgroundPause: true,\n                    batteryOptimization: true\n                }\n            },\n            tablet: {\n                performance: {\n                    targetFPS: 45,\n                    maxTextureSize: 2048,\n                    shadowQuality: 'medium',\n                    particleCount: 0.6,\n                    lodBias: 1.5\n                },\n                ui: {\n                    touchControls: true,\n                    virtualJoystick: false,\n                    adaptiveLayout: true,\n                    contextualMenus: true\n                }\n            },\n            desktop: {\n                performance: {\n                    targetFPS: 60,\n                    maxTextureSize: 4096,\n                    shadowQuality: 'high',\n                    particleCount: 1.0,\n                    lodBias: 1.0\n                },\n                ui: {\n                    keyboardControls: true,\n                    mouseControls: true,\n                    gamepadSupport: true,\n                    fullHUD: true\n                }\n            }\n        };\n        \n        // Touch control state\n        this.touchControls = {\n            enabled: false,\n            joystick: null,\n            buttons: new Map(),\n            gestures: {\n                pinchZoom: false,\n                swipeNavigation: false,\n                longPress: false\n            }\n        };\n        \n        // PWA state\n        this.pwa = {\n            installed: false,\n            installPrompt: null,\n            serviceWorker: null,\n            updateAvailable: false\n        };\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialize cross-platform manager\n     */\n    initialize() {\n        this.detectPlatform();\n        this.detectCapabilities();\n        this.detectPerformanceTier();\n        this.setupPlatformSpecificConfig();\n        this.initializeTouchControls();\n        this.initializePWA();\n        this.setupEventListeners();\n        \n        console.log('Cross-Platform Manager initialized:', this.platform);\n    }\n    \n    /**\n     * Detect platform type and OS\n     */\n    detectPlatform() {\n        const userAgent = navigator.userAgent.toLowerCase();\n        \n        // Detect OS\n        if (userAgent.includes('windows')) {\n            this.platform.os = 'windows';\n        } else if (userAgent.includes('mac')) {\n            this.platform.os = 'macos';\n        } else if (userAgent.includes('linux')) {\n            this.platform.os = 'linux';\n        } else if (userAgent.includes('iphone') || userAgent.includes('ipad')) {\n            this.platform.os = 'ios';\n        } else if (userAgent.includes('android')) {\n            this.platform.os = 'android';\n        }\n        \n        // Detect browser\n        if (userAgent.includes('chrome')) {\n            this.platform.browser = 'chrome';\n        } else if (userAgent.includes('firefox')) {\n            this.platform.browser = 'firefox';\n        } else if (userAgent.includes('safari')) {\n            this.platform.browser = 'safari';\n        } else if (userAgent.includes('edge')) {\n            this.platform.browser = 'edge';\n        }\n        \n        // Detect device type\n        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        const isTablet = /(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(navigator.userAgent);\n        \n        if (isTablet) {\n            this.platform.type = 'tablet';\n        } else if (isMobile) {\n            this.platform.type = 'mobile';\n        } else {\n            this.platform.type = 'desktop';\n        }\n        \n        // Update screen info\n        this.updateScreenInfo();\n    }\n    \n    /**\n     * Update screen information\n     */\n    updateScreenInfo() {\n        this.platform.screen = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n            pixelRatio: window.devicePixelRatio || 1,\n            orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'\n        };\n    }\n    \n    /**\n     * Detect device capabilities\n     */\n    detectCapabilities() {\n        const caps = this.platform.capabilities;\n        \n        // Touch support\n        caps.touch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        \n        // WebGL support\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl2');\n        caps.webgl2 = !!gl;\n        \n        // WebGPU support\n        caps.webgpu = 'gpu' in navigator;\n        \n        // Service Worker support\n        caps.serviceWorker = 'serviceWorker' in navigator;\n        \n        // WebAssembly support\n        caps.webAssembly = 'WebAssembly' in window;\n        \n        // Gamepad support\n        caps.gamepad = 'getGamepads' in navigator;\n        \n        // Fullscreen support\n        caps.fullscreen = document.fullscreenEnabled || document.webkitFullscreenEnabled;\n        \n        // Pointer lock support\n        caps.pointerLock = 'pointerLockElement' in document || 'webkitPointerLockElement' in document;\n    }\n    \n    /**\n     * Detect performance tier\n     */\n    detectPerformanceTier() {\n        const perf = this.platform.performance;\n        \n        // Memory detection\n        if (navigator.deviceMemory) {\n            perf.memory = navigator.deviceMemory;\n        }\n        \n        // CPU cores detection\n        if (navigator.hardwareConcurrency) {\n            perf.cores = navigator.hardwareConcurrency;\n        }\n        \n        // Performance tier calculation\n        let score = 0;\n        \n        // Memory score (0-40 points)\n        if (perf.memory >= 8) score += 40;\n        else if (perf.memory >= 4) score += 25;\n        else if (perf.memory >= 2) score += 15;\n        else score += 5;\n        \n        // CPU score (0-30 points)\n        if (perf.cores >= 8) score += 30;\n        else if (perf.cores >= 4) score += 20;\n        else if (perf.cores >= 2) score += 10;\n        else score += 5;\n        \n        // Platform penalty/bonus (0-30 points)\n        if (this.platform.type === 'desktop') score += 30;\n        else if (this.platform.type === 'tablet') score += 15;\n        else score += 5; // mobile\n        \n        // Determine tier\n        if (score >= 80) {\n            perf.tier = 'high';\n        } else if (score >= 50) {\n            perf.tier = 'medium';\n        } else {\n            perf.tier = 'low';\n        }\n    }\n    \n    /**\n     * Setup platform-specific configuration\n     */\n    setupPlatformSpecificConfig() {\n        const config = this.platformConfigs[this.platform.type];\n        if (!config) return;\n        \n        // Apply performance settings\n        if (this.gameEngine.performanceManager) {\n            this.gameEngine.performanceManager.updateConfig(config.performance);\n        }\n        \n        // Apply UI settings\n        if (this.gameEngine.uiManager) {\n            this.gameEngine.uiManager.updateConfig(config.ui);\n        }\n        \n        // Apply feature settings\n        if (config.features) {\n            Object.keys(config.features).forEach(feature => {\n                this.gameEngine.setFeature(feature, config.features[feature]);\n            });\n        }\n    }"  
  \n    /**\n     * Initialize touch controls\n     */\n    initializeTouchControls() {\n        if (!this.platform.capabilities.touch) return;\n        \n        this.touchControls.enabled = true;\n        \n        // Create virtual joystick for mobile\n        if (this.platform.type === 'mobile') {\n            this.createVirtualJoystick();\n        }\n        \n        // Create touch buttons\n        this.createTouchButtons();\n        \n        // Setup gesture recognition\n        this.setupGestureRecognition();\n        \n        // Setup touch event handlers\n        this.setupTouchEventHandlers();\n    }\n    \n    /**\n     * Create virtual joystick\n     */\n    createVirtualJoystick() {\n        const joystickContainer = document.createElement('div');\n        joystickContainer.className = 'virtual-joystick-container';\n        joystickContainer.style.cssText = `\n            position: fixed;\n            bottom: 20px;\n            left: 20px;\n            width: 120px;\n            height: 120px;\n            background: rgba(255, 255, 255, 0.1);\n            border: 2px solid rgba(255, 255, 255, 0.3);\n            border-radius: 50%;\n            z-index: 1000;\n            touch-action: none;\n        `;\n        \n        const joystickKnob = document.createElement('div');\n        joystickKnob.className = 'virtual-joystick-knob';\n        joystickKnob.style.cssText = `\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            width: 40px;\n            height: 40px;\n            background: rgba(255, 255, 255, 0.8);\n            border-radius: 50%;\n            transform: translate(-50%, -50%);\n            transition: all 0.1s ease;\n        `;\n        \n        joystickContainer.appendChild(joystickKnob);\n        document.body.appendChild(joystickContainer);\n        \n        this.touchControls.joystick = {\n            container: joystickContainer,\n            knob: joystickKnob,\n            active: false,\n            startPos: { x: 0, y: 0 },\n            currentPos: { x: 0, y: 0 },\n            value: { x: 0, y: 0 }\n        };\n        \n        this.setupJoystickEvents();\n    }\n    \n    /**\n     * Setup joystick events\n     */\n    setupJoystickEvents() {\n        const joystick = this.touchControls.joystick;\n        if (!joystick) return;\n        \n        const handleStart = (e) => {\n            e.preventDefault();\n            joystick.active = true;\n            const rect = joystick.container.getBoundingClientRect();\n            joystick.startPos = {\n                x: rect.left + rect.width / 2,\n                y: rect.top + rect.height / 2\n            };\n            joystick.container.style.background = 'rgba(255, 255, 255, 0.2)';\n        };\n        \n        const handleMove = (e) => {\n            if (!joystick.active) return;\n            e.preventDefault();\n            \n            const touch = e.touches ? e.touches[0] : e;\n            const deltaX = touch.clientX - joystick.startPos.x;\n            const deltaY = touch.clientY - joystick.startPos.y;\n            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n            const maxDistance = 40;\n            \n            if (distance <= maxDistance) {\n                joystick.currentPos = { x: deltaX, y: deltaY };\n            } else {\n                const angle = Math.atan2(deltaY, deltaX);\n                joystick.currentPos = {\n                    x: Math.cos(angle) * maxDistance,\n                    y: Math.sin(angle) * maxDistance\n                };\n            }\n            \n            // Update knob position\n            joystick.knob.style.transform = `translate(calc(-50% + ${joystick.currentPos.x}px), calc(-50% + ${joystick.currentPos.y}px))`;\n            \n            // Calculate normalized values\n            joystick.value = {\n                x: joystick.currentPos.x / maxDistance,\n                y: -joystick.currentPos.y / maxDistance // Invert Y for game coordinates\n            };\n            \n            // Send input to game engine\n            if (this.gameEngine.handleInput) {\n                this.gameEngine.handleInput('joystick', joystick.value);\n            }\n        };\n        \n        const handleEnd = (e) => {\n            e.preventDefault();\n            joystick.active = false;\n            joystick.currentPos = { x: 0, y: 0 };\n            joystick.value = { x: 0, y: 0 };\n            \n            // Reset knob position\n            joystick.knob.style.transform = 'translate(-50%, -50%)';\n            joystick.container.style.background = 'rgba(255, 255, 255, 0.1)';\n            \n            // Send stop input to game engine\n            if (this.gameEngine.handleInput) {\n                this.gameEngine.handleInput('joystick', { x: 0, y: 0 });\n            }\n        };\n        \n        // Touch events\n        joystick.container.addEventListener('touchstart', handleStart, { passive: false });\n        document.addEventListener('touchmove', handleMove, { passive: false });\n        document.addEventListener('touchend', handleEnd, { passive: false });\n        \n        // Mouse events for testing\n        joystick.container.addEventListener('mousedown', handleStart);\n        document.addEventListener('mousemove', handleMove);\n        document.addEventListener('mouseup', handleEnd);\n    }\n    \n    /**\n     * Create touch buttons\n     */\n    createTouchButtons() {\n        const buttons = [\n            { id: 'brake', label: 'Brake', position: 'bottom-right', offset: { x: -20, y: -20 } },\n            { id: 'accelerate', label: 'Gas', position: 'bottom-right', offset: { x: -20, y: -100 } },\n            { id: 'shoot', label: 'Shoot', position: 'bottom-right', offset: { x: -100, y: -60 } },\n            { id: 'pause', label: 'Pause', position: 'top-right', offset: { x: -20, y: 20 } }\n        ];\n        \n        buttons.forEach(buttonConfig => {\n            const button = this.createTouchButton(buttonConfig);\n            this.touchControls.buttons.set(buttonConfig.id, button);\n        });\n    }\n    \n    /**\n     * Create individual touch button\n     */\n    createTouchButton(config) {\n        const button = document.createElement('div');\n        button.className = `touch-button touch-button-${config.id}`;\n        button.textContent = config.label;\n        \n        // Position button\n        const position = this.calculateButtonPosition(config.position, config.offset);\n        button.style.cssText = `\n            position: fixed;\n            ${position.css}\n            width: 60px;\n            height: 60px;\n            background: rgba(255, 255, 255, 0.2);\n            border: 2px solid rgba(255, 255, 255, 0.5);\n            border-radius: 50%;\n            color: white;\n            font-size: 12px;\n            font-weight: bold;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 1000;\n            touch-action: none;\n            user-select: none;\n            transition: all 0.1s ease;\n        `;\n        \n        // Button events\n        const handleStart = (e) => {\n            e.preventDefault();\n            button.style.background = 'rgba(255, 255, 255, 0.4)';\n            button.style.transform = 'scale(0.95)';\n            if (this.gameEngine.handleInput) {\n                this.gameEngine.handleInput('button', { id: config.id, pressed: true });\n            }\n        };\n        \n        const handleEnd = (e) => {\n            e.preventDefault();\n            button.style.background = 'rgba(255, 255, 255, 0.2)';\n            button.style.transform = 'scale(1)';\n            if (this.gameEngine.handleInput) {\n                this.gameEngine.handleInput('button', { id: config.id, pressed: false });\n            }\n        };\n        \n        button.addEventListener('touchstart', handleStart, { passive: false });\n        button.addEventListener('touchend', handleEnd, { passive: false });\n        button.addEventListener('mousedown', handleStart);\n        button.addEventListener('mouseup', handleEnd);\n        \n        document.body.appendChild(button);\n        \n        return {\n            element: button,\n            config: config,\n            active: false\n        };\n    }\n    \n    /**\n     * Calculate button position\n     */\n    calculateButtonPosition(position, offset) {\n        const positions = {\n            'top-left': { css: `top: ${offset.y}px; left: ${offset.x}px;` },\n            'top-right': { css: `top: ${offset.y}px; right: ${-offset.x}px;` },\n            'bottom-left': { css: `bottom: ${-offset.y}px; left: ${offset.x}px;` },\n            'bottom-right': { css: `bottom: ${-offset.y}px; right: ${-offset.x}px;` }\n        };\n        \n        return positions[position] || positions['bottom-right'];\n    }"    \n    
/**\n     * Setup gesture recognition\n     */\n    setupGestureRecognition() {\n        let touchStartTime = 0;\n        let touchStartPos = { x: 0, y: 0 };\n        let lastTouchDistance = 0;\n        \n        const handleTouchStart = (e) => {\n            touchStartTime = Date.now();\n            \n            if (e.touches.length === 1) {\n                touchStartPos = {\n                    x: e.touches[0].clientX,\n                    y: e.touches[0].clientY\n                };\n            } else if (e.touches.length === 2) {\n                // Pinch gesture start\n                const touch1 = e.touches[0];\n                const touch2 = e.touches[1];\n                lastTouchDistance = Math.sqrt(\n                    Math.pow(touch2.clientX - touch1.clientX, 2) +\n                    Math.pow(touch2.clientY - touch1.clientY, 2)\n                );\n            }\n        };\n        \n        const handleTouchMove = (e) => {\n            if (e.touches.length === 2 && this.touchControls.gestures.pinchZoom) {\n                // Pinch zoom gesture\n                const touch1 = e.touches[0];\n                const touch2 = e.touches[1];\n                const currentDistance = Math.sqrt(\n                    Math.pow(touch2.clientX - touch1.clientX, 2) +\n                    Math.pow(touch2.clientY - touch1.clientY, 2)\n                );\n                \n                const scale = currentDistance / lastTouchDistance;\n                if (this.gameEngine.handleInput) {\n                    this.gameEngine.handleInput('pinchZoom', { scale });\n                }\n                lastTouchDistance = currentDistance;\n            }\n        };\n        \n        const handleTouchEnd = (e) => {\n            const touchDuration = Date.now() - touchStartTime;\n            \n            if (e.changedTouches.length === 1 && touchDuration > 500) {\n                // Long press gesture\n                if (this.touchControls.gestures.longPress && this.gameEngine.handleInput) {\n                    this.gameEngine.handleInput('longPress', {\n                        x: e.changedTouches[0].clientX,\n                        y: e.changedTouches[0].clientY\n                    });\n                }\n            } else if (e.changedTouches.length === 1 && touchDuration < 200) {\n                // Swipe gesture detection\n                const touchEndPos = {\n                    x: e.changedTouches[0].clientX,\n                    y: e.changedTouches[0].clientY\n                };\n                \n                const deltaX = touchEndPos.x - touchStartPos.x;\n                const deltaY = touchEndPos.y - touchStartPos.y;\n                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                \n                if (distance > 50 && this.touchControls.gestures.swipeNavigation) {\n                    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n                    let direction = 'unknown';\n                    \n                    if (angle >= -45 && angle <= 45) direction = 'right';\n                    else if (angle >= 45 && angle <= 135) direction = 'down';\n                    else if (angle >= -135 && angle <= -45) direction = 'up';\n                    else direction = 'left';\n                    \n                    if (this.gameEngine.handleInput) {\n                        this.gameEngine.handleInput('swipe', { direction, distance });\n                    }\n                }\n            }\n        };\n        \n        document.addEventListener('touchstart', handleTouchStart, { passive: true });\n        document.addEventListener('touchmove', handleTouchMove, { passive: true });\n        document.addEventListener('touchend', handleTouchEnd, { passive: true });\n    }\n    \n    /**\n     * Setup touch event handlers\n     */\n    setupTouchEventHandlers() {\n        // Prevent default touch behaviors that interfere with game\n        document.addEventListener('touchstart', (e) => {\n            if (e.target.closest('.game-canvas, .virtual-joystick-container, .touch-button')) {\n                e.preventDefault();\n            }\n        }, { passive: false });\n        \n        document.addEventListener('touchmove', (e) => {\n            if (e.target.closest('.game-canvas, .virtual-joystick-container, .touch-button')) {\n                e.preventDefault();\n            }\n        }, { passive: false });\n        \n        // Prevent context menu on long press\n        document.addEventListener('contextmenu', (e) => {\n            if (this.platform.type === 'mobile' || this.platform.type === 'tablet') {\n                e.preventDefault();\n            }\n        });\n    }\n    \n    /**\n     * Initialize Progressive Web App features\n     */\n    initializePWA() {\n        if (!this.platform.capabilities.serviceWorker) {\n            console.warn('Service Worker not supported, PWA features disabled');\n            return;\n        }\n        \n        this.registerServiceWorker();\n        this.setupInstallPrompt();\n        this.setupUpdateNotifications();\n        this.setupOfflineSupport();\n    }\n    \n    /**\n     * Register service worker\n     */\n    async registerServiceWorker() {\n        try {\n            const registration = await navigator.serviceWorker.register('/sw.js');\n            this.pwa.serviceWorker = registration;\n            \n            console.log('Service Worker registered successfully');\n            \n            // Listen for updates\n            registration.addEventListener('updatefound', () => {\n                const newWorker = registration.installing;\n                newWorker.addEventListener('statechange', () => {\n                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n                        this.pwa.updateAvailable = true;\n                        this.showUpdateNotification();\n                    }\n                });\n            });\n        } catch (error) {\n            console.error('Service Worker registration failed:', error);\n        }\n    }\n    \n    /**\n     * Setup install prompt\n     */\n    setupInstallPrompt() {\n        window.addEventListener('beforeinstallprompt', (e) => {\n            e.preventDefault();\n            this.pwa.installPrompt = e;\n            this.showInstallButton();\n        });\n        \n        window.addEventListener('appinstalled', () => {\n            this.pwa.installed = true;\n            this.hideInstallButton();\n            console.log('PWA installed successfully');\n        });\n    }\n    \n    /**\n     * Show install button\n     */\n    showInstallButton() {\n        const installButton = document.createElement('button');\n        installButton.id = 'pwa-install-button';\n        installButton.textContent = 'Install Game';\n        installButton.style.cssText = `\n            position: fixed;\n            top: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            background: #00ff00;\n            color: #000;\n            border: none;\n            padding: 10px 20px;\n            border-radius: 5px;\n            font-weight: bold;\n            cursor: pointer;\n            z-index: 10000;\n            animation: pulse 2s infinite;\n        `;\n        \n        installButton.addEventListener('click', () => {\n            this.installPWA();\n        });\n        \n        document.body.appendChild(installButton);\n    }\n    \n    /**\n     * Hide install button\n     */\n    hideInstallButton() {\n        const installButton = document.getElementById('pwa-install-button');\n        if (installButton) {\n            installButton.remove();\n        }\n    }\n    \n    /**\n     * Install PWA\n     */\n    async installPWA() {\n        if (!this.pwa.installPrompt) return;\n        \n        try {\n            const result = await this.pwa.installPrompt.prompt();\n            console.log('PWA install result:', result.outcome);\n            \n            if (result.outcome === 'accepted') {\n                this.pwa.installed = true;\n            }\n            \n            this.pwa.installPrompt = null;\n            this.hideInstallButton();\n        } catch (error) {\n            console.error('PWA installation failed:', error);\n        }\n    }\n    \n    /**\n     * Setup update notifications\n     */\n    setupUpdateNotifications() {\n        // This will be called when an update is available\n    }\n    \n    /**\n     * Show update notification\n     */\n    showUpdateNotification() {\n        const updateNotification = document.createElement('div');\n        updateNotification.id = 'pwa-update-notification';\n        updateNotification.innerHTML = `\n            <div style=\"\n                position: fixed;\n                top: 20px;\n                right: 20px;\n                background: #333;\n                color: white;\n                padding: 15px;\n                border-radius: 5px;\n                z-index: 10000;\n                max-width: 300px;\n            \">\n                <p>A new version is available!</p>\n                <button id=\"update-button\" style=\"\n                    background: #00ff00;\n                    color: #000;\n                    border: none;\n                    padding: 5px 10px;\n                    border-radius: 3px;\n                    cursor: pointer;\n                    margin-right: 10px;\n                \">Update</button>\n                <button id=\"dismiss-button\" style=\"\n                    background: #666;\n                    color: white;\n                    border: none;\n                    padding: 5px 10px;\n                    border-radius: 3px;\n                    cursor: pointer;\n                \">Later</button>\n            </div>\n        `;\n        \n        document.body.appendChild(updateNotification);\n        \n        // Update button handler\n        document.getElementById('update-button').addEventListener('click', () => {\n            this.updatePWA();\n            updateNotification.remove();\n        });\n        \n        // Dismiss button handler\n        document.getElementById('dismiss-button').addEventListener('click', () => {\n            updateNotification.remove();\n        });\n    }\n    \n    /**\n     * Update PWA\n     */\n    async updatePWA() {\n        if (!this.pwa.serviceWorker) return;\n        \n        try {\n            await this.pwa.serviceWorker.update();\n            window.location.reload();\n        } catch (error) {\n            console.error('PWA update failed:', error);\n        }\n    }\n    \n    /**\n     * Setup offline support\n     */\n    setupOfflineSupport() {\n        // Monitor online/offline status\n        window.addEventListener('online', () => {\n            console.log('Connection restored');\n            this.handleConnectionChange(true);\n        });\n        \n        window.addEventListener('offline', () => {\n            console.log('Connection lost');\n            this.handleConnectionChange(false);\n        });\n        \n        // Initial status\n        this.handleConnectionChange(navigator.onLine);\n    }\n    \n    /**\n     * Handle connection change\n     */\n    handleConnectionChange(isOnline) {\n        if (this.gameEngine && this.gameEngine.setOnlineStatus) {\n            this.gameEngine.setOnlineStatus(isOnline);\n        }\n        \n        // Show/hide offline indicator\n        this.updateOfflineIndicator(!isOnline);\n    }\n    \n    /**\n     * Update offline indicator\n     */\n    updateOfflineIndicator(isOffline) {\n        let indicator = document.getElementById('offline-indicator');\n        \n        if (isOffline && !indicator) {\n            indicator = document.createElement('div');\n            indicator.id = 'offline-indicator';\n            indicator.textContent = 'Offline Mode';\n            indicator.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                background: #ff6b6b;\n                color: white;\n                text-align: center;\n                padding: 10px;\n                z-index: 10000;\n                font-weight: bold;\n            `;\n            document.body.appendChild(indicator);\n        } else if (!isOffline && indicator) {\n            indicator.remove();\n        }\n    }"    
\n    /**\n     * Setup event listeners\n     */\n    setupEventListeners() {\n        // Window resize handler\n        window.addEventListener('resize', () => {\n            this.updateScreenInfo();\n            this.handleScreenResize();\n        });\n        \n        // Orientation change handler\n        window.addEventListener('orientationchange', () => {\n            setTimeout(() => {\n                this.updateScreenInfo();\n                this.handleOrientationChange();\n            }, 100);\n        });\n        \n        // Visibility change handler (for background pause)\n        document.addEventListener('visibilitychange', () => {\n            this.handleVisibilityChange();\n        });\n        \n        // Battery status (if available)\n        if ('getBattery' in navigator) {\n            navigator.getBattery().then(battery => {\n                this.handleBatteryChange(battery);\n                battery.addEventListener('levelchange', () => this.handleBatteryChange(battery));\n            });\n        }\n    }\n    \n    /**\n     * Handle screen resize\n     */\n    handleScreenResize() {\n        // Update UI scaling\n        this.updateUIScaling();\n        \n        // Notify game engine\n        if (this.gameEngine && this.gameEngine.handleResize) {\n            this.gameEngine.handleResize(this.platform.screen.width, this.platform.screen.height);\n        }\n        \n        // Reposition touch controls\n        this.repositionTouchControls();\n    }\n    \n    /**\n     * Handle orientation change\n     */\n    handleOrientationChange() {\n        console.log('Orientation changed to:', this.platform.screen.orientation);\n        \n        // Show orientation warning for mobile games that prefer landscape\n        if (this.platform.type === 'mobile' && this.platform.screen.orientation === 'portrait') {\n            this.showOrientationWarning();\n        } else {\n            this.hideOrientationWarning();\n        }\n        \n        // Notify game engine\n        if (this.gameEngine && this.gameEngine.handleOrientationChange) {\n            this.gameEngine.handleOrientationChange(this.platform.screen.orientation);\n        }\n    }\n    \n    /**\n     * Handle visibility change\n     */\n    handleVisibilityChange() {\n        const isHidden = document.hidden;\n        \n        if (isHidden && this.platformConfigs[this.platform.type]?.features?.backgroundPause) {\n            // Pause game when app goes to background\n            if (this.gameEngine && this.gameEngine.pause) {\n                this.gameEngine.pause();\n            }\n        } else if (!isHidden) {\n            // Resume game when app comes to foreground\n            if (this.gameEngine && this.gameEngine.resume) {\n                this.gameEngine.resume();\n            }\n        }\n    }\n    \n    /**\n     * Handle battery change\n     */\n    handleBatteryChange(battery) {\n        const batteryLevel = battery.level;\n        const isCharging = battery.charging;\n        \n        // Enable battery optimization on low battery\n        if (batteryLevel < 0.2 && !isCharging && this.platformConfigs[this.platform.type]?.features?.batteryOptimization) {\n            this.enableBatteryOptimization();\n        } else if (batteryLevel > 0.5 || isCharging) {\n            this.disableBatteryOptimization();\n        }\n    }\n    \n    /**\n     * Update UI scaling\n     */\n    updateUIScaling() {\n        const baseWidth = 1920;\n        const baseHeight = 1080;\n        const scaleX = this.platform.screen.width / baseWidth;\n        const scaleY = this.platform.screen.height / baseHeight;\n        const scale = Math.min(scaleX, scaleY);\n        \n        // Apply scaling to UI elements\n        document.documentElement.style.setProperty('--ui-scale', scale.toString());\n        \n        // Update touch control sizes\n        if (this.touchControls.enabled) {\n            this.updateTouchControlSizes(scale);\n        }\n    }\n    \n    /**\n     * Update touch control sizes\n     */\n    updateTouchControlSizes(scale) {\n        // Update joystick size\n        if (this.touchControls.joystick) {\n            const size = Math.max(80, 120 * scale);\n            this.touchControls.joystick.container.style.width = `${size}px`;\n            this.touchControls.joystick.container.style.height = `${size}px`;\n        }\n        \n        // Update button sizes\n        this.touchControls.buttons.forEach(button => {\n            const size = Math.max(40, 60 * scale);\n            button.element.style.width = `${size}px`;\n            button.element.style.height = `${size}px`;\n            button.element.style.fontSize = `${Math.max(10, 12 * scale)}px`;\n        });\n    }\n    \n    /**\n     * Reposition touch controls\n     */\n    repositionTouchControls() {\n        // Reposition buttons based on new screen size\n        this.touchControls.buttons.forEach(button => {\n            const position = this.calculateButtonPosition(button.config.position, button.config.offset);\n            button.element.style.cssText = button.element.style.cssText.replace(\n                /top: [^;]+;|bottom: [^;]+;|left: [^;]+;|right: [^;]+;/g,\n                position.css\n            );\n        });\n    }\n    \n    /**\n     * Show orientation warning\n     */\n    showOrientationWarning() {\n        let warning = document.getElementById('orientation-warning');\n        if (warning) return;\n        \n        warning = document.createElement('div');\n        warning.id = 'orientation-warning';\n        warning.innerHTML = `\n            <div style=\"\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                background: rgba(0, 0, 0, 0.8);\n                color: white;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                justify-content: center;\n                z-index: 10001;\n                text-align: center;\n                padding: 20px;\n            \">\n                <div style=\"font-size: 48px; margin-bottom: 20px;\">📱</div>\n                <h2>Please rotate your device</h2>\n                <p>This game is best played in landscape mode</p>\n            </div>\n        `;\n        \n        document.body.appendChild(warning);\n    }\n    \n    /**\n     * Hide orientation warning\n     */\n    hideOrientationWarning() {\n        const warning = document.getElementById('orientation-warning');\n        if (warning) {\n            warning.remove();\n        }\n    }\n    \n    /**\n     * Enable battery optimization\n     */\n    enableBatteryOptimization() {\n        console.log('Enabling battery optimization');\n        \n        // Reduce performance settings\n        const optimizedConfig = {\n            targetFPS: 20,\n            maxTextureSize: 512,\n            shadowQuality: 'off',\n            particleCount: 0.1,\n            lodBias: 3.0\n        };\n        \n        if (this.gameEngine.performanceManager) {\n            this.gameEngine.performanceManager.updateConfig(optimizedConfig);\n        }\n    }\n    \n    /**\n     * Disable battery optimization\n     */\n    disableBatteryOptimization() {\n        console.log('Disabling battery optimization');\n        \n        // Restore normal performance settings\n        const config = this.platformConfigs[this.platform.type];\n        if (config && this.gameEngine.performanceManager) {\n            this.gameEngine.performanceManager.updateConfig(config.performance);\n        }\n    }\n    \n    /**\n     * Get platform information\n     */\n    getPlatformInfo() {\n        return { ...this.platform };\n    }\n    \n    /**\n     * Check if feature is supported\n     */\n    isFeatureSupported(feature) {\n        return this.platform.capabilities[feature] || false;\n    }\n    \n    /**\n     * Get performance tier\n     */\n    getPerformanceTier() {\n        return this.platform.performance.tier;\n    }\n    \n    /**\n     * Enable/disable touch controls\n     */\n    setTouchControlsEnabled(enabled) {\n        this.touchControls.enabled = enabled;\n        \n        if (enabled && this.platform.capabilities.touch) {\n            this.initializeTouchControls();\n        } else {\n            this.disableTouchControls();\n        }\n    }\n    \n    /**\n     * Disable touch controls\n     */\n    disableTouchControls() {\n        // Remove joystick\n        if (this.touchControls.joystick) {\n            this.touchControls.joystick.container.remove();\n            this.touchControls.joystick = null;\n        }\n        \n        // Remove buttons\n        this.touchControls.buttons.forEach(button => {\n            button.element.remove();\n        });\n        this.touchControls.buttons.clear();\n    }\n    \n    /**\n     * Cleanup\n     */\n    destroy() {\n        this.disableTouchControls();\n        \n        // Remove event listeners\n        window.removeEventListener('resize', this.handleScreenResize);\n        window.removeEventListener('orientationchange', this.handleOrientationChange);\n        document.removeEventListener('visibilitychange', this.handleVisibilityChange);\n        \n        // Remove PWA elements\n        this.hideInstallButton();\n        this.hideOrientationWarning();\n        \n        const updateNotification = document.getElementById('pwa-update-notification');\n        if (updateNotification) updateNotification.remove();\n        \n        const offlineIndicator = document.getElementById('offline-indicator');\n        if (offlineIndicator) offlineIndicator.remove();\n    }\n}\n\nexport default CrossPlatformManager;"